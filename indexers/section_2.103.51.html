<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SERCOMx SPI Read Function | Microchip Documentation</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .sidebar {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            z-index: 100;
            padding: 48px 0 0;
            box-shadow: inset -1px 0 0 rgba(0, 0, 0, .1);
            overflow: hidden;
            width: 280px;
        }

        .nav-frame {
            width: 100%;
            height: 100%;
            border: none;
            overflow-y: scroll;
            overflow-x: hidden;
        }

        .main {
            margin-left: 280px;
            padding: 20px;
        }

        .nav-link {
            color: #333;
            padding: .5rem 1rem;
        }

        .nav-link.active {
            background-color: #f8f9fa;
            font-weight: 500;
        }

        .parameters-table {
            width: 100%;
            margin-bottom: 1rem;
            background-color: #f8f9fa;
        }
    </style>
</head>

<body>
    <div class="container-fluid">
        <div class="row">
            <nav class="sidebar">
                <iframe class="nav-frame" src="navigation.html" title="Navigation"></iframe>
            </nav>
            <main class="main">
<div class="doc-navigation">
    <a href="section_2.103.html">↑ Up to Section</a><br />
    <a href="index.html">↑↑ Back to Main Documentation</a>
</div>

<nav aria-label="breadcrumb">
    <ol class="breadcrumb">
        <li class="breadcrumb-item"><a href="index.html">Home</a></li>
        <li class="breadcrumb-item"><a href="section_2.html">API Documentation</a></li>
        <li class="breadcrumb-item"><a href="section_2.103.html">Serial Communication Interface (SERCOM)</a></li>
        <li class="breadcrumb-item active" aria-current="page">SERCOMx SPI Read Function</li>
    </ol>
</nav>

<h1>SERCOMx SPI Read Function</h1>
<h1>2.103.51</h1>
<p>SERCOMx_SPI_Read Function</p>
<p><em>Generated on: 2025-02-20 07:44:01</em></p>
<p>Source: <a href="https://onlinedocs.microchip.com/oxy/GUID-450989FA-38E4-4D68-AB61-15ADB29AD718-en-US-5/GUID-9E490459-95D0-47F2-B98A-FC5CB2622DAF.html">https://onlinedocs.microchip.com/oxy/GUID-450989FA-38E4-4D68-AB61-15ADB29AD718-en-US-5/GUID-9E490459-95D0-47F2-B98A-FC5CB2622DAF.html</a></p>
<h1><span id="2-103-51-sercomx-spi-read-function"></span>2.103.51 SERCOMx_SPI_Read Function</h1>
<h2><span id="c"></span>C</h2>
<p>```C
/<em> x = SERCOM instance number </em>/</p>
<p>/<em> SPI master mode </em>/</p>
<p>bool SERCOMx_SPI_Read(void* pRdBuffer, size_t rxSize)   </p>
<p>/<em> SPI slave mode </em>/</p>
<p>size_t SERCOMx_SPI_Read(void* pRdBuffer, size_t rxSize)
```</p>
<h2><span id="summary"></span>Summary</h2>
<p>SPI master mode</p>
<p>Reads data on the SERCOM SPI peripheral.</p>
<p>SPI slave mode</p>
<p>Reads data from the PLIB's internal buffer to the application buffer</p>
<h2><span id="description"></span>Description</h2>
<p>SPI master mode</p>
<p>This function reads "rxSize" number of bytes on SERCOM SPI module. The received data is stored in the buffer pointed by pRdBuffer.  When the interrupt is disabled in the PLIB, this function will be blocking in nature. In this mode, the function will not return until all the requested data is transferred. The function returns true after receiving "rxSize" number of bytes. This indicates that the operation has been completed.  When interrupt is enabled, the function will be non-blocking in nature. The function returns immediately. The data transfer process continues from the peripheral interrupt. The application specified receive buffer is owned by the PLIB until the data transfer is complete and should not be modified by the application till the transfer is complete. Only one transfer is allowed at any time. The application can use a callback function or a polling function to check for completion of the transfer. If a callback is required then it should be registered prior to calling the SERCOMx_SPI_Read() function. The application can use the SERCOMx_SPI_IsBusy() to poll for completion of transfer.</p>
<p>SPI slave mode</p>
<p>This function reads "rxSize" number of bytes received from SPI master. The function copies the data that is already received by the PLIB in its internal buffer to the application's buffer specified by pRdBuffer. The return value indicates the actual number of bytes copied to the application buffer. The SERCOMx_SPI_ReadCountGet API can be used to know the available bytes in the PLIB. Application must call this API from the callback function itself.</p>
<h2><span id="precondition"></span>Precondition</h2>
<p>The SERCOMx_SPI_Initialize function must have been called.</p>
<p>SPI master mode</p>
<p>Callback can be registered using SERCOMx_SPI_CallbackRegister API if the PLIB is configured in Interrupt mode and transfer completion status needs to be communicated back to application via callback.</p>
<p>SPI slave mode</p>
<p>Callback must have been registered using SERCOMx_SPI_CallbackRegister API to get notified when the transfer is complete.</p>
<h2><span id="parameters"></span>Parameters</h2>
<p>SPI master mode</p>
<p>SPI slave mode</p>
<h3>Parameters</h3>
<table class="data-table">
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pRdBuffer</td>
<td>Pointer to the buffer where the received data will be stored. For 9 bit mode, data should be right aligned in the 16 bit memory location. In "Interrupt Mode", this buffer should not be modified after calling the function and before the callback function has been called or the SERCOMx_SPI_IsBusy() function returns false.</td>
</tr>
<tr>
<td>rxSize</td>
<td>Number of bytes to be received. This value is the byte size of the buffer. For 9 bit data length, this is an even number.</td>
</tr>
<tr>
<td>pRdBuffer</td>
<td>Pointer to the buffer where the data from the PLIB's internal buffer must be copied</td>
</tr>
<tr>
<td>rxSize</td>
<td>Number of bytes to copy. For 9-bit mode, the rxSize must be specified in terms of 16-bit words.</td>
</tr>
</tbody>
</table>
<table class="data-table">
<thead>
<tr>
<th>Param</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pRdBuffer</td>
<td>Pointer to the buffer where the received data will be stored. For 9 bit mode, data should be right aligned in the 16 bit memory location. In "Interrupt Mode", this buffer should not be modified after calling the function and before the callback function has been called or the SERCOMx_SPI_IsBusy() function returns false.</td>
</tr>
<tr>
<td>rxSize</td>
<td>Number of bytes to be received. This value is the byte size of the buffer. For 9 bit data length, this is an even number.</td>
</tr>
</tbody>
</table>
<table class="data-table">
<thead>
<tr>
<th>Param</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>pRdBuffer</td>
<td>Pointer to the buffer where the data from the PLIB's internal buffer must be copied</td>
</tr>
<tr>
<td>rxSize</td>
<td>Number of bytes to copy. For 9-bit mode, the rxSize must be specified in terms of 16-bit words.</td>
</tr>
</tbody>
</table>
<h2><span id="returns"></span>Returns</h2>
<p>SPI master mode</p>
<p>true - If configured for non-interrupt mode, the function has received the requested number of bytes. If configured for Interrupt mode, the request was accepted successfully and will be processed in the interrupt.</p>
<p>false - If pRdBuffer is NULL or rxSize is 0. In Interrupt mode, the function will additionally return false if there is an on-going data transfer at the time of calling the function.</p>
<p>SPI slave mode</p>
<p>Returns the number of bytes (or 16-bit words if PLIB is in 9-bit mode) actually copied into the pRdBuffer</p>
<h2><span id="example"></span>Example</h2>
<p>SPI master mode</p>
<p>SPI slave mode</p>
<p>```C
uint8_t rxBuffer[10];
size_t rxSize = 10;</p>
<p>void APP_SPITransferHandler(uintptr_t context)
{
    //Transfer was completed without error, do something else now.
}</p>
<p>SERCOM0_SPI_Initialize();
SERCOM0_SPI_CallbackRegister(&amp;APP_SPITransferHandler, (uintptr_t)NULL);
if(SERCOM0_SPI_Read(&amp;rxBuffer, rxSize))
{
    // request got accepted
}
else
{
    // request didn't get accepted, try again later with correct arguments
}
```</p>
<p>```C
uint8_t APP_RxData[10];</p>
<p>void SPIEventHandler(uintptr_t context )
{
    if (SERCOM0_SPI_ErrorGet() == SPI_SLAVE_ERROR_NONE)
    {
        // Read out the received data. This could be meaningful data if SPI master is
        // writing to slave or it could be dummy data if SPI master is reading from slave.
        // However, irrespective of whether slave is expecting meaningful data or dummy
        // data from master, SPI slave must always read out the data to clear the PLIB's
        // internal receive buffer.</p>
<pre class="code-block"><code class="language-c">    appData.nBytesRead = SERCOM0_SPI_Read(APP_RxData, SERCOM0_SPI_ReadCountGet());
}
else
{
    // Handle error
}
</code></pre>
<p>}</p>
<p>SERCOM0_SPI_CallbackRegister(SPIEventHandler, (uintptr_t) 0);
```</p>
<h2><span id="remarks"></span>Remarks</h2>
<p>None</p>
            </main>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>