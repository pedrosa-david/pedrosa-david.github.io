<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Controller Area Network (CAN) | Microchip Documentation</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .sidebar {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            z-index: 100;
            padding: 48px 0 0;
            box-shadow: inset -1px 0 0 rgba(0, 0, 0, .1);
            overflow: hidden;
            width: 280px;
        }

        .nav-frame {
            width: 100%;
            height: 100%;
            border: none;
            overflow-y: scroll;
            overflow-x: hidden;
        }

        .main {
            margin-left: 280px;
            padding: 20px;
        }

        .nav-link {
            color: #333;
            padding: .5rem 1rem;
        }

        .nav-link.active {
            background-color: #f8f9fa;
            font-weight: 500;
        }

        .parameters-table {
            width: 100%;
            margin-bottom: 1rem;
            background-color: #f8f9fa;
        }
    </style>
</head>

<body>
    <div class="container-fluid">
        <div class="row">
            <nav class="sidebar">
                <iframe class="nav-frame" src="navigation.html" title="Navigation"></iframe>
            </nav>
            <main class="main">
<div class="doc-navigation">
    <a href="section_3.28.html">↑ Up to Section</a><br />
    <a href="index.html">↑↑ Back to Main Documentation</a>
</div>

<nav aria-label="breadcrumb">
    <ol class="breadcrumb">
        <li class="breadcrumb-item"><a href="index.html">Home</a></li>
        <li class="breadcrumb-item"><a href="section_3.html">Device Families</a></li>
        <li class="breadcrumb-item"><a href="section_3.28.html">SAM 9X60 Peripheral Libraries</a></li>
        <li class="breadcrumb-item active" aria-current="page">Controller Area Network (CAN)</li>
    </ol>
</nav>

<h1>Controller Area Network (CAN)</h1>
<h1>3.28.3</h1>
<p>Controller Area Network (CAN)</p>
<p><em>Generated on: 2025-02-19 08:42:44</em></p>
<p>Source: <a href="https://onlinedocs.microchip.com/oxy/GUID-450989FA-38E4-4D68-AB61-15ADB29AD718-en-US-5/GUID-0A0B6128-8FFC-4B4C-AC48-294B984F5C8C.html">https://onlinedocs.microchip.com/oxy/GUID-450989FA-38E4-4D68-AB61-15ADB29AD718-en-US-5/GUID-0A0B6128-8FFC-4B4C-AC48-294B984F5C8C.html</a></p>
<h1>3.28.3 Controller Area Network (CAN)</h1>
<p>The CAN controller provides all the features required to implement the serial
            communication protocol CAN, the CAN specification as referred to by ISO/11898A (2.0 Part
            A and 2.0 Part B) for high speeds and ISO/11519-2 for low speeds. The CAN Controller is
            able to handle all types of frames (Data, Remote, Error and Overload) and achieves a
            bitrate of 1 Mbit/s.</p>
<p>CAN controller accesses are made through configuration registers. 8 independent message
            objects (mailboxes) are implemented.</p>
<p>Any mailbox can be programmed as a reception buffer block (even non-consecutive buffers).
            For the reception of defined messages, one or several message objects can be masked
            without participating in the buffer feature. An interrupt is generated when the buffer
            is full. According to the mailbox configuration, the first message received can be
            locked in the CAN controller registers until the application acknowledges it, or this
            message can be discarded by new received messages.</p>
<p>Any mailbox can be programmed for transmission. Several transmission mailboxes can be
            enabled in the same time.</p>
<h2>Using The Library</h2>
<p>The CAN library supports the normal mode. The CAN Plib can transfer message in a
                polling or an interrupt mode.</p>
<p>CAN normal operation with polling</p>
<p>CAN normal operation with interrupt</p>
<p>The following example shows the CAN normal mode operation with interrupt
            implementation.</p>
<p>```C</p>
<h1>include <stddef.h>                     // Defines NULL</stddef.h></h1>
<h1>include <stdbool.h>                    // Defines true</stdbool.h></h1>
<h1>include <stdlib.h>                     // Defines EXIT_FAILURE</stdlib.h></h1>
<h1>include "definitions.h"                // SYS function prototypes</h1>
<p>/<em> LED Toggle </em>/</p>
<h1>define LED_Toggle() LED_GREEN_Toggle()</h1>
<p>void print_menu(void)
{
    printf(" ------------------------------ \r\n"); <br/>
    printf(" Press '1' to Transmit message \r\n");
    printf(" Press '2' to Receive message \r\n");
}</p>
<p>// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// Section: Main Entry Point
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong></p>
<p>int main ( void )
{
    uint8_t user_input = 0;
    uint32_t messageID = 0;
    uint8_t message[8];
    uint8_t messageLength = 0;
    uint32_t status = 0;</p>
<pre class="code-block"><code class="language-c">uint8_t rx_message[8];
uint32_t rx_messageID = 0;
uint8_t rx_messageLength = 0;
CAN_MSG_RX_ATTRIBUTE msgAttr = CAN_MSG_RX_DATA_FRAME;

/* Initialize all modules */
SYS_Initialize ( NULL );

LED_RED_Clear();
LED_GREEN_Clear();
LED_BLUE_Clear();

printf(" ------------------------------ \r\n");
printf("            CAN Demo            \r\n");
printf(" ------------------------------ \r\n");

print_menu();

/* Prepare the message to send*/
messageID = 0x469;
messageLength = 8;
for (uint8_t count = 8; count &gt;=1; count--){
    message[count - 1] = count;
}

while ( true )
{
    /* Maintain state machines of all polled Harmony modules. */
    scanf("%c", (char *) &amp;user_input);

    switch (user_input)
    {
        case '1': 
            printf(" Transmitting Message:");
            if (CAN1_MessageTransmit(messageID, messageLength, message, CAN_MAILBOX_DATA_FRAME_TX) == true)
            {    
                printf("Success \r\n");
                LED_Toggle();
            }
            else
            {
                printf("Failed \r\n");
            }             
            break;
        case '2':
            printf(" Waiting for message: \r\n");
            while (true)
            {
                if (CAN1_InterruptGet(CAN_INTERRUPT_MB1_MASK))
                {
                    /* Check CAN Status */
                    status = CAN1_ErrorGet();

                    if ((status &amp; (CAN_ERROR_BOFF | CAN_ERROR_CERR |
                                    CAN_ERROR_SERR | CAN_ERROR_AERR |
                                    CAN_ERROR_FERR | CAN_ERROR_BERR)) == CAN_ERROR_NONE)
                    {
                        memset(rx_message, 0x00, sizeof(rx_message));

                        /* Receive New Message */
                        if (CAN1_MessageReceive(&amp;rx_messageID, &amp;rx_messageLength, rx_message, 0, CAN_MAILBOX_DATA_FRAME_RX_OVERWRITE, &amp;msgAttr) == true)  
                        {
                            printf(" New Message Received    \r\n");
                            status = CAN1_ErrorGet();
                            if ((status &amp; (CAN_ERROR_BOFF | CAN_ERROR_CERR |
                                           CAN_ERROR_SERR | CAN_ERROR_AERR |
                                           CAN_ERROR_FERR | CAN_ERROR_BERR)) == CAN_ERROR_NONE)
                            {
                                /* Print message to Console */
                                uint8_t length = rx_messageLength;
                                printf(" Message - ID : 0x%x Length : 0x%x ", (unsigned int) rx_messageID,(unsigned int) rx_messageLength);
                                printf("Message : ");
                                while(length)
                                {
                                    printf("0x%x ", rx_message[rx_messageLength - length--]);
                                }
                                printf("\r\n");
                                LED_Toggle();
                                break;
                            }
                            else
                            {
                                printf("Error in received message");
                            }
                        }
                        else
                        {
                            printf("Message Reception Failed \r");
                        }
                    }
                    else
                    {
                        printf("Error in last received message");
                    }
                }
            }
            break;
        default:
            printf(" Invalid Input \r\n");
            break;
    }

    print_menu();

}

/* Execution should not come here during normal operation */

return ( EXIT_FAILURE );
</code></pre>
<p>}
```</p>
<p>```C</p>
<h1>include <stddef.h>                     // Defines NULL</stddef.h></h1>
<h1>include <stdbool.h>                    // Defines true</stdbool.h></h1>
<h1>include <stdlib.h>                     // Defines EXIT_FAILURE</stdlib.h></h1>
<h1>include "definitions.h"                // SYS function prototypes</h1>
<p>/<em> Application's state machine enum </em>/
typedef enum
{
    APP_STATE_CAN_RECEIVE,
    APP_STATE_CAN_TRANSMIT,
    APP_STATE_CAN_IDLE,
    APP_STATE_CAN_USER_INPUT,
    APP_STATE_CAN_XFER_SUCCESSFUL,
    APP_STATE_CAN_XFER_ERROR
} APP_STATES;</p>
<p>/<em> LED Toggle </em>/</p>
<h1>define LED_Toggle() LED_GREEN_Toggle()</h1>
<p>/<em> Variable to save application state </em>/
static APP_STATES state = APP_STATE_CAN_USER_INPUT;
/<em> Variable to save Tx/Rx transfer status and context </em>/
static uint32_t status = 0;
static uint32_t xferContext = 0;
/<em> Variable to save Tx/Rx message </em>/
static uint32_t messageID = 0;
static uint8_t message[8];
static uint8_t messageLength = 0;
static uint8_t rx_message[8];
static uint32_t rx_messageID = 0;
static uint8_t rx_messageLength = 0;
static CAN_MSG_RX_ATTRIBUTE msgAttr = CAN_MSG_RX_DATA_FRAME;</p>
<p>// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// Section: Local functions
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong></p>
<p>/<em> This function will be called by CAN PLIB when transfer is completed </em>/
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
/* void APP_CAN_Callback(uintptr_t context)</p>
<p>Summary:
    Function called by CAN PLIB upon transfer completion</p>
<p>Description:
    This function will be called by CAN PLIB when transfer is completed.
    In this function, current state of the application is obtained by context
    parameter. Based on current state of the application and CAN error
    state, next state of the application is decided.</p>
<p>Remarks:
    None.
*/
void APP_CAN_Callback(uintptr_t context)
{
    xferContext = context;</p>
<pre class="code-block"><code class="language-c">/* Check CAN Status */
status = CAN1_ErrorGet();

if ((status &amp; (CAN_ERROR_BOFF | CAN_ERROR_CERR |
               CAN_ERROR_SERR | CAN_ERROR_AERR |
               CAN_ERROR_FERR | CAN_ERROR_BERR)) == CAN_ERROR_NONE)
{
    switch ((APP_STATES)context)
    {
        case APP_STATE_CAN_RECEIVE:
        case APP_STATE_CAN_TRANSMIT:
        {
            state = APP_STATE_CAN_XFER_SUCCESSFUL;
            break;
        }
        default:
            break;
    }
}
else
{
    state = APP_STATE_CAN_XFER_ERROR;
}
</code></pre>
<p>}</p>
<p>void print_menu(void)
{
    printf(" ------------------------------ \r\n"); <br/>
    printf(" Press '1' to Transmit message \r\n");
    printf(" Press '2' to Receive message \r\n");
}</p>
<p>// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// Section: Main Entry Point
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong></p>
<p>int main ( void )
{
    uint8_t user_input = 0;</p>
<pre class="code-block"><code class="language-c">/* Initialize all modules */
SYS_Initialize ( NULL );

LED_RED_Clear();
LED_GREEN_Clear();
LED_BLUE_Clear();

printf(" ------------------------------ \r\n");
printf("            CAN Demo            \r\n");
printf(" ------------------------------ \r\n");

print_menu();

/* Prepare the message to send*/
messageID = 0x469;
messageLength = 8;
for (uint8_t count = 8; count &gt;=1; count--){
    message[count - 1] = count;
}

while ( true )
{
    if (state == APP_STATE_CAN_USER_INPUT)
    {
        /* Read user input */
        scanf("%c", (char *) &amp;user_input);

        switch (user_input)
        {
            case '1': 
                printf(" Transmitting Message:");
                CAN1_TxCallbackRegister( APP_CAN_Callback, (uintptr_t)APP_STATE_CAN_TRANSMIT, CAN_MAILBOX_DATA_FRAME_TX );
                state = APP_STATE_CAN_IDLE;
                if (CAN1_MessageTransmit(messageID, messageLength, message, CAN_MAILBOX_DATA_FRAME_TX) == false)
                {
                    printf("CAN1_MessageTransmit request has failed\r\n");
                }             
                break;
            case '2':
                printf(" Waiting for message: \r\n");
                CAN1_RxCallbackRegister( APP_CAN_Callback, (uintptr_t)APP_STATE_CAN_RECEIVE, CAN_MAILBOX_DATA_FRAME_RX_OVERWRITE );
                state = APP_STATE_CAN_IDLE;
                memset(rx_message, 0x00, sizeof(rx_message));
                /* Receive New Message */
                if (CAN1_MessageReceive(&amp;rx_messageID, &amp;rx_messageLength, rx_message, 0, CAN_MAILBOX_DATA_FRAME_RX_OVERWRITE, &amp;msgAttr) == false)  
                {
                    printf("CAN1_MessageReceive request has failed\r\n");
                }
                break;
            default:
                printf(" Invalid Input \r\n");
                break;
        }
    }
    /* Check the application's current state. */
    switch (state)
    {
        case APP_STATE_CAN_IDLE:
        {
            /* Application can do other task here */
            break;
        }
        case APP_STATE_CAN_XFER_SUCCESSFUL:
        {
            if ((APP_STATES)xferContext == APP_STATE_CAN_RECEIVE)
            {
                /* Print message to Console */
                printf(" New Message Received    \r\n");
                uint8_t length = rx_messageLength;
                printf(" Message - ID : 0x%x Length : 0x%x ", (unsigned int) rx_messageID,(unsigned int) rx_messageLength);
                printf("Message : ");
                while(length)
                {
                    printf("0x%x ", rx_message[rx_messageLength - length--]);
                }
                printf("\r\n");
            } 
            else if ((APP_STATES)xferContext == APP_STATE_CAN_TRANSMIT)
            {
                printf("Success \r\n");
            }
            LED_Toggle();
            print_menu();
            state = APP_STATE_CAN_USER_INPUT;
            break;
        }
        case APP_STATE_CAN_XFER_ERROR:
        {
            if ((APP_STATES)xferContext == APP_STATE_CAN_RECEIVE)
            {
                printf("Error in received message");
            }
            else
            {
                printf("Failed \r\n");
            }
            print_menu();
            state = APP_STATE_CAN_USER_INPUT;
            break;
        }
        default:
            break;
    }

}

/* Execution should not come here during normal operation */

return ( EXIT_FAILURE );
</code></pre>
<p>}
```</p>
<h2>Library Interface</h2>
<p>Controller Area Network peripheral library provides the following interfaces:</p>
<p>Functions</p>
<p>Data types and constants</p>
<table class="data-table">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CANx_Initialize</td>
<td>Initializes given instance of the CAN peripheral</td>
</tr>
<tr>
<td>CANx_MessageTransmit</td>
<td>Transmits a message into CAN bus</td>
</tr>
<tr>
<td>CANx_MessageReceive</td>
<td>Receives a message from CAN bus</td>
</tr>
<tr>
<td>CANx_MessageAbort</td>
<td>Abort request for a Mailbox</td>
</tr>
<tr>
<td>CANx_MessageIDSet</td>
<td>Set Message ID in mailbox</td>
</tr>
<tr>
<td>CANx_MessageIDGet</td>
<td>Get Message ID from mailbox</td>
</tr>
<tr>
<td>CANx_MessageAcceptanceMaskSet</td>
<td>Set Message acceptance identifier mask in mailbox</td>
</tr>
<tr>
<td>CANx_MessageAcceptanceMaskGet</td>
<td>Get Message acceptance identifier mask from mailbox</td>
</tr>
<tr>
<td>CANx_MessageTimestampGet</td>
<td>Get the message timestamp from a mailbox</td>
</tr>
<tr>
<td>CANx_ErrorGet</td>
<td>Returns the error during transfer</td>
</tr>
<tr>
<td>CANx_ErrorCountGet</td>
<td>Returns the transmit and receive error count during transfer</td>
</tr>
<tr>
<td>CANx_InterruptGet</td>
<td>Returns the Interrupt status</td>
</tr>
<tr>
<td>CANx_InterruptEnable</td>
<td>Enables CAN Interrupt</td>
</tr>
<tr>
<td>CANx_InterruptDisable</td>
<td>Disables CAN Interrupt</td>
</tr>
<tr>
<td>CANx_MailboxIsReady</td>
<td>Returns true if Mailbox is ready otherwise false</td>
</tr>
<tr>
<td>CANx_BitTimingCalculationGet</td>
<td>Returns the bit timing information</td>
</tr>
<tr>
<td>CANx_BitTimingSet</td>
<td>Sets the bit timing</td>
</tr>
<tr>
<td>CANx_TxCallbackRegister</td>
<td>Sets the pointer to the function (and it's context) to be called when the given CAN's Tx transfer events occur</td>
</tr>
<tr>
<td>CANx_RxCallbackRegister</td>
<td>Sets the pointer to the function (and it's context) to be called when the given CAN's Rx transfer events occur</td>
</tr>
</tbody>
</table>
<table class="data-table">
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CAN_MAILBOX_TX_ATTRIBUTE</td>
<td>Enum</td>
<td>CAN Mailbox TX Attribute for Transmit mailbox, Producer Tx Mailbox and Consumer Tx Mailbox</td>
</tr>
<tr>
<td>CAN_MAILBOX_RX_ATTRIBUTE</td>
<td>Enum</td>
<td>CAN Mailbox RX Attribute for Reception Mailbox, Reception Mailbox with overwrite, Consumer Rx Mailbox and Producer Rx Mailbox</td>
</tr>
<tr>
<td>CAN_MSG_RX_ATTRIBUTE</td>
<td>Enum</td>
<td>CAN Message RX Attribute for Data Frame and Remote Frame</td>
</tr>
<tr>
<td>CAN_MAILBOX_NUM</td>
<td>Enum</td>
<td>CAN Mailbox Number</td>
</tr>
<tr>
<td>CAN_MAILBOX_MASK</td>
<td>Enum</td>
<td>CAN Mailbox Mask</td>
</tr>
<tr>
<td>CAN_ERROR</td>
<td>Enum</td>
<td>CAN Transfer Error data type</td>
</tr>
<tr>
<td>CAN_INTERRUPT_MASK</td>
<td>Enum</td>
<td>CAN Interrupt Mask</td>
</tr>
<tr>
<td>CAN_MAILBOX_STATE</td>
<td>Enum</td>
<td>CAN Mailbox State</td>
</tr>
<tr>
<td>CAN_CALLBACK</td>
<td>Typedef</td>
<td>CAN Callback Function Pointer</td>
</tr>
<tr>
<td>CAN_RX_MSG</td>
<td>Struct</td>
<td>CAN PLib Object structure</td>
</tr>
<tr>
<td>CAN_MAILBOX_CALLBACK</td>
<td>Struct</td>
<td>CAN transfer event callback structure</td>
</tr>
<tr>
<td>CAN_NOMINAL_BIT_TIMING</td>
<td>Struct</td>
<td>Nominal bit timing parameters</td>
</tr>
<tr>
<td>CAN_BIT_TIMING</td>
<td>Struct</td>
<td>Bit timing parameters</td>
</tr>
</tbody>
</table>
            </main>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>