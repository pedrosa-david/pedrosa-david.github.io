<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inter-Integrated Circuit - I2C | Microchip Documentation</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .sidebar {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            z-index: 100;
            padding: 48px 0 0;
            box-shadow: inset -1px 0 0 rgba(0, 0, 0, .1);
            overflow: hidden;
            width: 280px;
        }

        .nav-frame {
            width: 100%;
            height: 100%;
            border: none;
            overflow-y: scroll;
            overflow-x: hidden;
        }

        .main {
            margin-left: 280px;
            padding: 20px;
        }

        .nav-link {
            color: #333;
            padding: .5rem 1rem;
        }

        .nav-link.active {
            background-color: #f8f9fa;
            font-weight: 500;
        }

        .parameters-table {
            width: 100%;
            margin-bottom: 1rem;
            background-color: #f8f9fa;
        }
    </style>
</head>

<body>
    <div class="container-fluid">
        <div class="row">
            <nav class="sidebar">
                <iframe class="nav-frame" src="navigation.html" title="Navigation"></iframe>
            </nav>
            <main class="main">
<div class="doc-navigation">
    <a href="section_3.26.html">↑ Up to Section</a><br />
    <a href="index.html">↑↑ Back to Main Documentation</a>
</div>

<nav aria-label="breadcrumb">
    <ol class="breadcrumb">
        <li class="breadcrumb-item"><a href="index.html">Home</a></li>
        <li class="breadcrumb-item"><a href="section_3.html">Device Families</a></li>
        <li class="breadcrumb-item"><a href="section_3.26.html">PIC32MZ EF Peripheral Libraries</a></li>
        <li class="breadcrumb-item active" aria-current="page">Inter-Integrated Circuit - I2C</li>
    </ol>
</nav>

<h1>Inter-Integrated Circuit - I2C</h1>
<h1>3.26.13</h1>
<p>Inter-Integrated Circuit - I2C</p>
<p><em>Generated on: 2025-02-19 08:42:44</em></p>
<p>Source: <a href="https://onlinedocs.microchip.com/oxy/GUID-450989FA-38E4-4D68-AB61-15ADB29AD718-en-US-5/GUID-780F823C-6165-429F-AC21-CA8764D20E46_6.html">https://onlinedocs.microchip.com/oxy/GUID-450989FA-38E4-4D68-AB61-15ADB29AD718-en-US-5/GUID-780F823C-6165-429F-AC21-CA8764D20E46_6.html</a></p>
<h1>3.26.13 Inter-Integrated Circuit - I2C</h1>
<p>The I2C PLIB can be configured in master or slave mode.</p>
<p>I2C master mode
The I2C peripheral library supports the following I2C transfers:</p>
<p>Master Write: The master writes a block of data to the slave
Master Read: The master reads a block of data from the slave
Master Write/Read: The master writes and then reads back a block of data from slave.</p>
<p>Additionally, a forced write API allows writes even if the address or data is NACKed by the slave.</p>
<p>The block of data is transferred in a non-blocking manner using a peripheral interrupt. Application can either use a callback or IsBusy API to check for completion of data transfer.</p>
<p>I2C slave mode</p>
<p>I2C slave PLIB works with peripheral interrupt enabled. Application must register a callback, to get notified of the I2C events such as address match, transmitter ready, receiver ready etc.</p>
<p>I2C Master mode</p>
<p>I2C Slave mode</p>
<p>This example uses the I2C peripheral library in slave mode and emulates an EEPROM of 512 bytes. There are two pages each of size 256 bytes. I2C slave expects two bytes of memory address from the I2C master and the memory address can range from 0x00 to 0x1FF.</p>
<p>```C
// Following code demonstrates I2C write operation using polling method</p>
<h1>define APP_SLAVE_ADDR 0x0057</h1>
<h1>define NUM_BYTES      10</h1>
<p>uint8_t myWriteData [NUM_BYTES] = {'1', '0', ' ', 'B', 'Y', 'T', 'E', 'S', '!', '!',};</p>
<p>int main(void)
{
    /<em> Initialize all modules </em>/
    SYS_Initialize ( NULL );</p>
<pre class="code-block"><code class="language-c">/* Write data to the I2C Slave */
I2C1_Write(APP_SLAVE_ADDR, &amp;myWriteData[0], NUM_BYTES);

/* Poll and wait for the transfer to complete */
while(I2C1_IsBusy());

/* Check if any error occurred */
if(I2C1_ErrorGet() == I2C_ERROR_NONE)
{
    //Transfer is completed successfully
}
else
{
    //Error occurred during transfer.
}
...
</code></pre>
<p>}
```</p>
<p>```C
// Following code demonstrates I2C write operation using callback method</p>
<h1>define APP_SLAVE_ADDR 0x0057</h1>
<h1>define NUM_BYTES      10</h1>
<p>uint8_t myWriteData [NUM_BYTES] = {'1', '0', ' ', 'B', 'Y', 'T', 'E', 'S', '!', '!',};</p>
<p>void I2C1_Callback(uintptr_t context)
{
    if(I2C1_ErrorGet() == I2C_ERROR_NONE)
    {
        //Transfer is completed successfully
    }
    else
    {
        //Error occurred during transfer.
    }
}</p>
<p>int main(void)
{
    /<em> Initialize all modules </em>/
    SYS_Initialize ( NULL );</p>
<pre class="code-block"><code class="language-c">/* Register Callback function */
I2C1_CallbackRegister(I2C1_Callback, (uintptr_t)NULL);

/* Submit Write Request */
I2C1_Write(APP_SLAVE_ADDR, &amp;myWriteData[0], NUM_BYTES);

...
</code></pre>
<p>}
```</p>
<p>```C</p>
<h1>define EEPROM_PAGE_SIZE_BYTES                  256</h1>
<h1>define EEPROM_PAGE_SIZE_MASK                   0xFF</h1>
<h1>define EEPROM_SIZE_BYTES                       512</h1>
<p>// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// Section: Main Entry Point
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong></p>
<p>typedef struct
{
    /<em> currentAddrPtr - to allow for sequential read (from the current address) </em>/
    uint16_t                    currentAddrPtr;
    /<em> addrIndex - used to copy 2 bytes of EEPROM memory address </em>/
    uint8_t                     addrIndex;      <br/>
}EEPROM_DATA;</p>
<p>EEPROM_DATA         eepromData;</p>
<p>uint8_t EEPROM_EmulationBuffer[EEPROM_SIZE_BYTES] =
{
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
    0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
    0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
    0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
    0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
    0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
    0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
    0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
    0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
    0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
    0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
    0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,</p>
<pre class="code-block"><code class="language-c">0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
</code></pre>
<p>};</p>
<p>bool APP_I2C_SLAVE_Callback ( I2C_SLAVE_TRANSFER_EVENT event, uintptr_t contextHandle )
{
    bool isSuccess = true;</p>
<pre class="code-block"><code class="language-c">switch(event)
{
    case I2C_SLAVE_TRANSFER_EVENT_ADDR_MATCH:

        /* Reset the index. MSB address is sent first followed by LSB. */
        eepromData.addrIndex = 2;

        break;

    case I2C_SLAVE_TRANSFER_EVENT_RX_READY:
        /* Read the data sent by I2C Master */
        if (eepromData.addrIndex &gt; 0)
        {
            ((uint8_t*)&amp;eepromData.currentAddrPtr)[--eepromData.addrIndex] = I2C1_ReadByte();
        }
        else
        {
            EEPROM_EmulationBuffer[eepromData.currentAddrPtr++] = I2C1_ReadByte();

            /* If exceeding the page boundary, rollover to the start of the page */
            if ((eepromData.currentAddrPtr % EEPROM_PAGE_SIZE_BYTES) == 0)
            {
                eepromData.currentAddrPtr -= EEPROM_PAGE_SIZE_BYTES;
            }                                                              
        }
        break;

    case I2C_SLAVE_TRANSFER_EVENT_TX_READY:

        /* Provide the EEPROM data requested by the I2C Master */
        I2C1_WriteByte(EEPROM_EmulationBuffer[eepromData.currentAddrPtr++]);
        if (eepromData.currentAddrPtr &gt;= EEPROM_SIZE_BYTES)
        {
            eepromData.currentAddrPtr = 0;
        }
        break;

    default:
        break;
}

return isSuccess;
</code></pre>
<p>}</p>
<p>int main ( void )
{
    /<em> Initialize all modules </em>/
    SYS_Initialize ( NULL );</p>
<pre class="code-block"><code class="language-c">I2C1_CallbackRegister(APP_I2C_SLAVE_Callback, 0);

while ( true )
{

}

/* Execution should not come here during normal operation */

return ( EXIT_FAILURE );
</code></pre>
<p>}
```</p>
<h2>Library Interface</h2>
<p>I2C Mode</p>
<p>Functions</p>
<p>Data types and constants</p>
<table class="data-table">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Master mode</th>
<th>Slave mode</th>
</tr>
</thead>
<tbody>
<tr>
<td>I2Cx_Initialize</td>
<td>Initializes the instance of the I2C peripheral in either master or slave mode</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>I2Cx_Read</td>
<td>Reads data from the slave</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>I2Cx_Write</td>
<td>Writes data to the slave</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>I2Cx_WriteRead</td>
<td>Write and Read data from Slave</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>I2Cx_WriteForced</td>
<td>Forced write data to the slave</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>I2Cx_IsBusy</td>
<td>Returns the Peripheral busy status</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>I2Cx_ErrorGet</td>
<td>Returns the I2C error that occurred on the bus</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>I2Cx_TransferSetup</td>
<td>Dynamic setup of I2C Peripheral</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>I2Cx_CallbackRegister</td>
<td>Sets the pointer to the function (and it's context) to be called when the given I2C's transfer events occur</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>I2Cx_ReadByte</td>
<td>Read the received I2C byte</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>I2Cx_WriteByte</td>
<td>Write a data byte to I2C master</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>I2Cx_TransferDirGet</td>
<td>Returns the I2C transfer direction</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>I2Cx_LastByteAckStatusGet</td>
<td>Returns the ACK status of the last byte written to the I2C master</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>I2Cx_BusScan Function</td>
<td>Scans and reports the target devices found on the bus</td>
<td>Yes</td>
<td>No</td>
</tr>
</tbody>
</table>
<table class="data-table">
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Master mode</th>
<th>Slave mode</th>
</tr>
</thead>
<tbody>
<tr>
<td>I2C_ERROR</td>
<td>Enum</td>
<td>Defines the possible errors that the I2C peripheral can generate in I2C master mode</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>I2C_TRANSFER_SETUP</td>
<td>Struct</td>
<td>I2C transfer setup data structure</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>I2C_CALLBACK</td>
<td>Typedef</td>
<td>Defines the data type and function signature for the I2C peripheral callback function in I2C master mode</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>I2C_SLAVE_TRANSFER_DIR</td>
<td>Enum</td>
<td>Defines the enum for I2C data transfer direction</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>I2C_SLAVE_ACK_STATUS</td>
<td>Enum</td>
<td>Defines the enum for the I2C acknowledgement</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>I2C_SLAVE_TRANSFER_EVENT</td>
<td>Enum</td>
<td>Defines the enum for the I2C slave transfer event</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>I2C_SLAVE_ERROR</td>
<td>Enum</td>
<td>Defines errors associated with I2C in slave mode</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>I2C_SLAVE_CALLBACK</td>
<td>Typedef</td>
<td>Defines the data type and function signature for the I2C Slave callback function</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table>
            </main>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>