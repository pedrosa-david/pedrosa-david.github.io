<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Controller Area Network (CAN) | Microchip Documentation</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .sidebar {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            z-index: 100;
            padding: 48px 0 0;
            box-shadow: inset -1px 0 0 rgba(0, 0, 0, .1);
            overflow: hidden;
            width: 280px;
        }

        .nav-frame {
            width: 100%;
            height: 100%;
            border: none;
            overflow-y: scroll;
            overflow-x: hidden;
        }

        .main {
            margin-left: 280px;
            padding: 20px;
        }

        .nav-link {
            color: #333;
            padding: .5rem 1rem;
        }

        .nav-link.active {
            background-color: #f8f9fa;
            font-weight: 500;
        }

        .parameters-table {
            width: 100%;
            margin-bottom: 1rem;
            background-color: #f8f9fa;
        }
    </style>
</head>

<body>
    <div class="container-fluid">
        <div class="row">
            <nav class="sidebar">
                <iframe class="nav-frame" src="navigation.html" title="Navigation"></iframe>
            </nav>
            <main class="main">
<div class="doc-navigation">
    <a href="section_3.15.html">↑ Up to Section</a><br />
    <a href="index.html">↑↑ Back to Main Documentation</a>
</div>

<nav aria-label="breadcrumb">
    <ol class="breadcrumb">
        <li class="breadcrumb-item"><a href="index.html">Home</a></li>
        <li class="breadcrumb-item"><a href="section_3.html">Device Families</a></li>
        <li class="breadcrumb-item"><a href="section_3.15.html">PIC32MK GPK MCM Peripheral Libraries</a></li>
        <li class="breadcrumb-item active" aria-current="page">Controller Area Network (CAN)</li>
    </ol>
</nav>

<h1>Controller Area Network (CAN)</h1>
<h1>3.15.2</h1>
<p>Controller Area Network (CAN)</p>
<p><em>Generated on: 2025-02-19 08:42:44</em></p>
<p>Source: <a href="https://onlinedocs.microchip.com/oxy/GUID-450989FA-38E4-4D68-AB61-15ADB29AD718-en-US-5/GUID-7C5DC30F-E484-42D0-AF3E-49AFFF73E695_2.html">https://onlinedocs.microchip.com/oxy/GUID-450989FA-38E4-4D68-AB61-15ADB29AD718-en-US-5/GUID-7C5DC30F-E484-42D0-AF3E-49AFFF73E695_2.html</a></p>
<h1>3.15.2 Controller Area Network (CAN)</h1>
<p>The Controller Area Network with Flexible Data-rate (CAN FD) module
supports the following key features:</p>
<p>Standards Compliance:</p>
<p>Full CAN 2.0B compliance</p>
<p>Programmable bit rate</p>
<p>ISO118981:2015 plus CAN FD 1.0 compliant, supports up to 64
data bytes payload/message</p>
<p>Arbitration Bit Rate up to one Mbps</p>
<p>FD Bit Rate up to eight Mbps
Message Reception and Transmission:</p>
<p>32 message FIFOs</p>
<p>Each FIFO can have up to 32 messages for a total of 512 messages</p>
<p>FIFO can be a transmit message FIFO or a receive message FIFO</p>
<p>User defined priority levels for message FIFOs used for transmission</p>
<p>32 acceptance filters for message filtering</p>
<p>32 acceptance filter mask registers for message filtering</p>
<p>Automatic response to Remote Transmit Request (RTR)</p>
<p>Using The Library</p>
<p>The CAN library supports the CAN FD and CAN Classic (Normal) mode. The
CAN FD and CAN Classic (Normal) mode can transfer message in a polling
or an interrupt mode.</p>
<p>CAN FD operation with polling</p>
<p>The following example shows the CAN FD mode operation with polling
implementation.</p>
<p>CAN FD operation with interrupt</p>
<p>The following example shows the CAN FD mode operation with interrupt
implementation.</p>
<p>Library Interface</p>
<p>peripheral library provides the following interfaces:</p>
<p>Functions</p>
<p>Data types and constants</p>
<p>```C
void print_menu(void)</p>
<p>{</p>
<p>printf("Menu :\r\n"</p>
<p>" -- Select the action:\r\n"</p>
<p>" 1: Send FD standard message with ID: 0x45A and 64 byte data 0 to 63.
\r\n"</p>
<p>" 2: Send normal standard message with ID: 0x469 and 8 byte data 0 to
\7. \r\n"</p>
<p>" 3: To receive CAN FD or Normal message \r\n"</p>
<p>" m: Display menu \r\n\r\n");</p>
<p>}</p>
<p>int main ( void )
{</p>
<p>uint32_t messageID = 0;</p>
<p>uint32_t rx_messageID = 0;</p>
<p>uint32_t status = 0;</p>
<p>uint8_t messageLength = 0;</p>
<p>uint8_t rx_messageLength = 0;</p>
<p>uint8_t count = 0;</p>
<p>uint8_t user_input = 0;</p>
<p>CANFD_MSG_RX_ATTRIBUTE msgAttr = CANFD_MSG_RX_DATA_FRAME;</p>
<p>/<em> Initialize all modules </em>/</p>
<p>SYS_Initialize ( NULL );</p>
<p>printf(" ------------------------------ \r\n");</p>
<p>printf(" CAN FD Demo \r\n");</p>
<p>printf(" ------------------------------ \r\n");</p>
<p>print_menu();</p>
<p>/<em> Prepare the message to send</em>/</p>
<p>for (count = 0; count \&lt; 64; count++)</p>
<p>{</p>
<p>message[count] = count;</p>
<p>}</p>
<p>while ( true )</p>
<p>{</p>
<p>/<em> Maintain state machines of all polled Harmony modules. </em>/</p>
<p>/<em> Check if there is a received character </em>/</p>
<p>if(UART2_ReceiverIsReady() == true)</p>
<p>{</p>
<p>if(UART2_ErrorGet() == UART_ERROR_NONE)</p>
<p>{</p>
<p>UART2_Read((void *)&amp;user_input, 1);</p>
<p>}</p>
<p>switch (user_input)</p>
<p>{</p>
<p>case '1':</p>
<p>printf(" Transmitting CAN FD Message:");</p>
<p>messageID = 0x45A;</p>
<p>messageLength = 64;</p>
<p>if (CAN1_MessageTransmit(messageID, messageLength, message, 1,
CANFD_MODE_FD_WITH_BRS, CANFD_MSG_TX_DATA_FRAME) == true)</p>
<p>{</p>
<p>printf("Success \r\n");</p>
<p>LED_Toggle();</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>printf("Failed \r\n");</p>
<p>}</p>
<p>break;</p>
<p>case '2':</p>
<p>printf(" Transmitting CAN Normal Message:");</p>
<p>messageID = 0x469;</p>
<p>messageLength = 8;</p>
<p>if (CAN1_MessageTransmit(messageID, messageLength, message, 1,
CANFD_MODE_NORMAL, CANFD_MSG_TX_DATA_FRAME) == true)</p>
<p>{</p>
<p>printf("Success \r\n");</p>
<p>LED_Toggle();</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>printf("Failed \r\n");</p>
<p>}</p>
<p>break;</p>
<p>case '3':</p>
<p>printf(" Waiting for message: \r\n");</p>
<p>while (true)</p>
<p>{</p>
<p>if (CAN1_InterruptGet(2, CANFD_FIFO_INTERRUPT_TFNRFNIF_MASK))</p>
<p>{</p>
<p>/<em> Check CAN Status </em>/</p>
<p>status = CAN1_ErrorGet();</p>
<p>if (status == CANFD_ERROR_NONE)</p>
<p>{</p>
<p>memset(rx_message, 0x00, sizeof(rx_message));</p>
<p>/<em> Receive New Message </em>/</p>
<p>if (CAN1_MessageReceive(&amp;rx_messageID, &amp;rx_messageLength,
rx_message, 0, 2, &amp;msgAttr) == true)</p>
<p>{</p>
<p>printf(" New Message Received \r\n");</p>
<p>status = CAN1_ErrorGet();</p>
<p>if (status == CANFD_ERROR_NONE)</p>
<p>{</p>
<p>/<em> Print message to Console </em>/</p>
<p>uint8_t length = rx_messageLength;</p>
<p>printf(" Message - ID : 0x%x Length : 0x%x ", (unsigned int)
rx_messageID,(unsigned int) rx_messageLength);</p>
<p>printf("Message : ");</p>
<p>while(length)</p>
<p>{</p>
<p>printf("0x%x ", rx_message[rx_messageLength - length--]);</p>
<p>}</p>
<p>printf("\r\n");</p>
<p>LED_Toggle();</p>
<p>break;</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>printf("Error in received message");</p>
<p>}</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>printf("Message Reception Failed \r");</p>
<p>}</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>printf("Error in last received message");</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>break;</p>
<p>default:</p>
<p>printf(" Invalid Input \r\n");</p>
<p>break;</p>
<p>}</p>
<p>print_menu();</p>
<p>}</p>
<p>}</p>
<p>/<em> Execution should not come here during normal operation </em>/</p>
<p>return ( EXIT_FAILURE );</p>
<p>}
```</p>
<p>```C
/<em> Application's state machine enum </em>/</p>
<p>typedef enum</p>
<p>{</p>
<p>APP_STATE_CAN_RECEIVE,</p>
<p>APP_STATE_CAN_TRANSMIT,</p>
<p>APP_STATE_CAN_IDLE,</p>
<p>APP_STATE_CAN_USER_INPUT,</p>
<p>APP_STATE_CAN_XFER_SUCCESSFUL,</p>
<p>APP_STATE_CAN_XFER_ERROR</p>
<p>} APP_STATES;</p>
<p>/<em> Variable to save application state </em>/</p>
<p>static APP_STATES state = APP_STATE_CAN_USER_INPUT;</p>
<p>void APP_CAN_Callback(uintptr_t context)</p>
<p>{</p>
<p>xferContext = context;</p>
<p>/<em> Check CAN Status </em>/</p>
<p>status = CAN1_ErrorGet();</p>
<p>if ((status &amp; (CANFD_ERROR_TX_RX_WARNING_STATE |
CANFD_ERROR_RX_WARNING_STATE |</p>
<p>CANFD_ERROR_TX_WARNING_STATE | CANFD_ERROR_RX_BUS_PASSIVE_STATE |</p>
<p>CANFD_ERROR_TX_BUS_PASSIVE_STATE | CANFD_ERROR_TX_BUS_OFF_STATE)) ==
CANFD_ERROR_NONE)</p>
<p>{</p>
<p>switch ((APP_STATES)context)</p>
<p>{</p>
<p>case APP_STATE_CAN_RECEIVE:</p>
<p>case APP_STATE_CAN_TRANSMIT:</p>
<p>{</p>
<p>state = APP_STATE_CAN_XFER_SUCCESSFUL;</p>
<p>break;</p>
<p>}</p>
<p>default:</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>state = APP_STATE_CAN_XFER_ERROR;</p>
<p>}</p>
<p>}</p>
<p>int main ( void )
{</p>
<p>uint8_t count = 0;</p>
<p>bool user_input = 0;</p>
<p>/<em> Initialize all modules </em>/</p>
<p>SYS_Initialize ( NULL );</p>
<p>/<em> Prepare the message to send</em>/</p>
<p>messageID = 0x45A;</p>
<p>messageLength = 64;</p>
<p>for (count = 0; count \&lt; 64; count++)</p>
<p>{</p>
<p>message[count] = count;</p>
<p>}</p>
<p>while ( true )</p>
<p>{</p>
<p>if (state == APP_STATE_CAN_USER_INPUT)</p>
<p>{</p>
<p>if(SWITCH_Get() == SWITCH_PRESSED_STATE)</p>
<p>{</p>
<p>while(SWITCH_Get() == SWITCH_PRESSED_STATE);</p>
<p>switch (user_input)</p>
<p>{</p>
<p>case 0:</p>
<p>CAN1_CallbackRegister( APP_CAN_Callback,
(uintptr_t)APP_STATE_CAN_TRANSMIT, 1 );</p>
<p>state = APP_STATE_CAN_IDLE;</p>
<p>CAN1_MessageTransmit(messageID, messageLength, message, 1,
CANFD_MODE_FD_WITH_BRS, CANFD_MSG_TX_DATA_FRAME);</p>
<p>break;</p>
<p>case 1:</p>
<p>CAN1_CallbackRegister( APP_CAN_Callback,
(uintptr_t)APP_STATE_CAN_RECEIVE, 2 );</p>
<p>state = APP_STATE_CAN_IDLE;</p>
<p>memset(rx_message, 0x00, sizeof(rx_message));</p>
<p>/<em> Receive New Message </em>/</p>
<p>CAN1_MessageReceive(&amp;rx_messageID, &amp;rx_messageLength, rx_message,
0, 2, &amp;msgAttr);</p>
<p>break;</p>
<p>default:</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>continue;</p>
<p>}</p>
<p>}</p>
<p>/<em> Check the application's current state. </em>/</p>
<p>switch (state)</p>
<p>{</p>
<p>case APP_STATE_CAN_IDLE:</p>
<p>{</p>
<p>/<em> Application can do other task here </em>/</p>
<p>break;</p>
<p>}</p>
<p>case APP_STATE_CAN_XFER_SUCCESSFUL:</p>
<p>{</p>
<p>if ((APP_STATES)xferContext == APP_STATE_CAN_RECEIVE)</p>
<p>{</p>
<p>}</p>
<p>else if ((APP_STATES)xferContext == APP_STATE_CAN_TRANSMIT)</p>
<p>{</p>
<p>}</p>
<p>LED_Toggle();</p>
<p>state = APP_STATE_CAN_USER_INPUT;</p>
<p>break;</p>
<p>}</p>
<p>case APP_STATE_CAN_XFER_ERROR:</p>
<p>{</p>
<p>if ((APP_STATES)xferContext == APP_STATE_CAN_RECEIVE)</p>
<p>{</p>
<p>}</p>
<p>else</p>
<p>{</p>
<p>}</p>
<p>state = APP_STATE_CAN_USER_INPUT;</p>
<p>break;</p>
<p>}</p>
<p>default:</p>
<p>break;</p>
<p>}</p>
<p>}</p>
<p>/<em> Execution should not come here during normal operation </em>/</p>
<p>return ( EXIT_FAILURE );
}
```</p>
<table class="data-table">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CANx_Initialize</td>
<td>Initializes given instance of the CAN peripheral</td>
</tr>
<tr>
<td>CANx_MessageTransmit</td>
<td>Transmits a message into CAN bus</td>
</tr>
<tr>
<td>CANx_MessageReceive</td>
<td>Receives a message from CAN bus</td>
</tr>
<tr>
<td>CANx_MessageAbort</td>
<td>Abort request for a FIFO</td>
</tr>
<tr>
<td>CANx_MessageAcceptanceFilterSet</td>
<td>Set Message acceptance filter configuration</td>
</tr>
<tr>
<td>CANx_MessageAcceptanceFilterGet</td>
<td>Get Message acceptance filter configuration</td>
</tr>
<tr>
<td>CANx_MessageAcceptanceFilterMaskSet</td>
<td>Set Message acceptance filter mask configuration</td>
</tr>
<tr>
<td>CANx_MessageAcceptanceFilterMaskGet</td>
<td>Get Message acceptance filter mask configuration</td>
</tr>
<tr>
<td>CANx_TransmitEventFIFOElementGet</td>
<td>Get the Transmit Event FIFO Element for the transmitted message</td>
</tr>
<tr>
<td>CANx_ErrorGet</td>
<td>Returns the error during transfer</td>
</tr>
<tr>
<td>CANx_ErrorCountGet</td>
<td>Returns the transmit and receive error count during transfer</td>
</tr>
<tr>
<td>CANx_InterruptGet</td>
<td>Returns the FIFO Interrupt status</td>
</tr>
<tr>
<td>CANx_TxFIFOQueueIsFull</td>
<td>Returns true if Tx FIFO/Queue is full otherwise false</td>
</tr>
<tr>
<td>CANx_AutoRTRResponseSet</td>
<td>Set the Auto RTR response for remote transmit request</td>
</tr>
<tr>
<td>CANx_BitTimingCalculationGet</td>
<td>Returns the bit timing information</td>
</tr>
<tr>
<td>CANx_BitTimingSet</td>
<td>Sets the bit timing</td>
</tr>
<tr>
<td>CANx_CallbackRegister</td>
<td>Sets the pointer to the function (and it's context) to be called when the given CAN's transfer events occur</td>
</tr>
<tr>
<td>CANx_ErrorCallbackRegister</td>
<td>Sets the pointer to the function (and it's context) to be called when error occurs in CAN</td>
</tr>
</tbody>
</table>
<table class="data-table">
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CANFD_MODE</td>
<td>Enum</td>
<td>CANFD Mode for Classic CAN and CAN FD</td>
</tr>
<tr>
<td>CANFD_MSG_TX_ATTRIBUTE</td>
<td>Enum</td>
<td>CANFD Tx Message Attribute for Tx FIFO and Tx Queue</td>
</tr>
<tr>
<td>CANFD_MSG_RX_ATTRIBUTE</td>
<td>Enum</td>
<td>CANFD Message RX Attribute for Data Frame and Remote Frame</td>
</tr>
<tr>
<td>CANFD_FIFO_INTERRUPT_FLAG_MASK</td>
<td>Enum</td>
<td>CANFD FIFO Interrupt Status Flag Mask</td>
</tr>
<tr>
<td>CANFD_ERROR</td>
<td>Enum</td>
<td>CANFD Transfer Error data type</td>
</tr>
<tr>
<td>CANFD_CALLBACK</td>
<td>Typedef</td>
<td>CANFD Callback Function Pointer</td>
</tr>
<tr>
<td>CANFD_RX_MSG</td>
<td>Struct</td>
<td>CANFD RX Message Buffer structure</td>
</tr>
<tr>
<td>CANFD_RX_MSG_OBJECT</td>
<td>Struct</td>
<td>CANFD Receive Message Object structure</td>
</tr>
<tr>
<td>CANFD_TX_MSG_OBJECT</td>
<td>Struct</td>
<td>CANFD Transmit Message Object structure</td>
</tr>
<tr>
<td>CANFD_TX_EVENT_FIFO_ELEMENT</td>
<td>Struct</td>
<td>CANFD Trasmit Event FIFO Element structure</td>
</tr>
<tr>
<td>CAN_NOMINAL_BIT_TIMING</td>
<td>Struct</td>
<td>Nominal bit timing parameters</td>
</tr>
<tr>
<td>CAN_BIT_TIMING</td>
<td>Struct</td>
<td>Bit timing parameters</td>
</tr>
</tbody>
</table>
<ul>
<li>Full CAN 2.0B compliance</li>
<li>Programmable bit rate</li>
<li>ISO118981:2015 plus CAN FD 1.0 compliant, supports up to 64
data bytes payload/message</li>
<li>Arbitration Bit Rate up to one Mbps</li>
<li>FD Bit Rate up to eight Mbps
Message Reception and Transmission:</li>
<li>32 message FIFOs</li>
<li>Each FIFO can have up to 32 messages for a total of 512 messages</li>
<li>FIFO can be a transmit message FIFO or a receive message FIFO</li>
<li>User defined priority levels for message FIFOs used for transmission</li>
<li>32 acceptance filters for message filtering</li>
<li>32 acceptance filter mask registers for message filtering</li>
<li>Automatic response to Remote Transmit Request (RTR)</li>
</ul>
            </main>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>