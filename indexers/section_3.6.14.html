<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Non-Volatile Memory Controller (NVMCTRL) | Microchip Documentation</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .sidebar {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            z-index: 100;
            padding: 48px 0 0;
            box-shadow: inset -1px 0 0 rgba(0, 0, 0, .1);
            overflow: hidden;
            width: 280px;
        }

        .nav-frame {
            width: 100%;
            height: 100%;
            border: none;
            overflow-y: scroll;
            overflow-x: hidden;
        }

        .main {
            margin-left: 280px;
            padding: 20px;
        }

        .nav-link {
            color: #333;
            padding: .5rem 1rem;
        }

        .nav-link.active {
            background-color: #f8f9fa;
            font-weight: 500;
        }

        .parameters-table {
            width: 100%;
            margin-bottom: 1rem;
            background-color: #f8f9fa;
        }
    </style>
</head>

<body>
    <div class="container-fluid">
        <div class="row">
            <nav class="sidebar">
                <iframe class="nav-frame" src="navigation.html" title="Navigation"></iframe>
            </nav>
            <main class="main">
<div class="doc-navigation">
    <a href="section_3.6.html">↑ Up to Section</a><br />
    <a href="index.html">↑↑ Back to Main Documentation</a>
</div>

<nav aria-label="breadcrumb">
    <ol class="breadcrumb">
        <li class="breadcrumb-item"><a href="index.html">Home</a></li>
        <li class="breadcrumb-item"><a href="section_3.html">Device Families</a></li>
        <li class="breadcrumb-item"><a href="section_3.6.html">PIC32CM MC00 Peripheral Libraries</a></li>
        <li class="breadcrumb-item active" aria-current="page">Non-Volatile Memory Controller (NVMCTRL)</li>
    </ol>
</nav>

<h1>Non-Volatile Memory Controller (NVMCTRL)</h1>
<h1>3.6.14</h1>
<p>Non-Volatile Memory Controller (NVMCTRL)</p>
<p><em>Generated on: 2025-02-19 08:42:44</em></p>
<p>Source: <a href="https://onlinedocs.microchip.com/oxy/GUID-450989FA-38E4-4D68-AB61-15ADB29AD718-en-US-5/GUID-24281246-8FA4-4961-96F4-33B246A6761F_2.html">https://onlinedocs.microchip.com/oxy/GUID-450989FA-38E4-4D68-AB61-15ADB29AD718-en-US-5/GUID-24281246-8FA4-4961-96F4-33B246A6761F_2.html</a></p>
<h1>3.6.14 Non-Volatile Memory Controller (NVMCTRL)</h1>
<p>The Non-Volatile Memory (NVM) module provides an interface to the device's Non-Volatile Memory controller, so that memory pages can be written, read, erased, and reconfigured in a standardized manner.</p>
<h2>Using The Library</h2>
<p>The main Flash memory can not be read while it is being erased or written, the CPU is stalled during the entire operation.</p>
<p>All functions that modify the main Flash can be run from RAM memory to avoid CPU stall
            while main Flash is being erased or written.</p>
<p>Some devices has the Flash region that support read-while-write feature, it is called
            Data Flash. The user could execute code from main Flash while the Data Flash is being
            erased or written.</p>
<p>The FLASH memory is divided into a number of physical rows, each containing four identically sized flash pages. Pages may be read or written to individually, however pages must be erased before being reprogrammed and the smallest granularity available for erasure is one single row.</p>
<p>NVM APIs are implemented to be non-blocking, the API will return immediately unless stalled by Flash operation. The user application can either use polling or callback method to indicate the transfer status.</p>
<p>With polling, the application will need to continuously check if the flash operation is completed.</p>
<p>With callback, the registered callback function will be called once the flash operation is completed. This means the application do not have to poll continuously.</p>
<p>Here is an example code to erase a row and program a page of memory using polling method</p>
<p>```C
// Define a constant array in Flash.
// It must be aligned to row boundary and size has to be in multiple of rows
const uint8_t nvm_user_start_address[NVMCTRL_FLASH_ROWSIZE] <strong>attribute</strong>((aligned(NVMCTRL_FLASH_ROWSIZE),keep,externally_visible,space(prog)))= {0};</p>
<p>void populate_buffer(uint8_t* data)
{
    int i = 0;</p>
<pre class="code-block"><code class="language-c">for (i = 0; i &lt; (NVMCTRL_FLASH_PAGESIZE); i++)
{
    *(data + i) = i;
}
</code></pre>
<p>}</p>
<p>int main (void)
{
    uint8_t pageBuffer[NVMCTRL_FLASH_PAGESIZE] = {0};</p>
<pre class="code-block"><code class="language-c">/*Populate pageBuffer to programmed*/
populate_buffer(pageBuffer);

while(NVMCTRL_IsBusy());

/* Erase the row */
NVMCTRL_RowErase((uint32_t)nvm_user_start_address);

/* Wait for row erase  to complete */
while(NVMCTRL_IsBusy());

/* Program a page of data */
NVMCTRL_PageWrite((uint32_t *)pageBuffer, (uint32_t)nvm_user_start_address);

/* Wait for page program to compete */
while(NVMCTRL_IsBusy());
</code></pre>
<p>}
```</p>
<ul>
<li>All functions that modify the main Flash can be run from RAM memory to avoid CPU stall
            while main Flash is being erased or written.</li>
<li>
<p>Some devices has the Flash region that support read-while-write feature, it is called
            Data Flash. The user could execute code from main Flash while the Data Flash is being
            erased or written.</p>
</li>
<li>
<p>With polling, the application will need to continuously check if the flash operation is completed.</p>
</li>
<li>With callback, the registered callback function will be called once the flash operation is completed. This means the application do not have to poll continuously.</li>
</ul>
<h2>Library Interface</h2>
<p>Non-Volatile Memory Controller peripheral library provides the following interfaces:</p>
<p>Functions</p>
<p>Data types and constants</p>
<table class="data-table">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>NVMCTRL_Initialize</td>
<td>Initializes given instance of the NVMCTRL peripheral</td>
</tr>
<tr>
<td>NVMCTRL_Read</td>
<td>Reads length number of bytes from a given address in FLASH memory</td>
</tr>
<tr>
<td>NVMCTRL_PageWrite</td>
<td>Writes one page of data to given NVM address</td>
</tr>
<tr>
<td>NVMCTRL_RowErase</td>
<td>Erases a Row in the NVM</td>
</tr>
<tr>
<td>NVMCTRL_ErrorGet</td>
<td>Returns the error state of NVM controller</td>
</tr>
<tr>
<td>NVMCTRL_IsBusy</td>
<td>Returns the current status of NVM controller</td>
</tr>
<tr>
<td>NVMCTRL_RegionLock</td>
<td>Locks a NVMCTRL region</td>
</tr>
<tr>
<td>NVMCTRL_RegionUnlock</td>
<td>Unlocks a NVM region</td>
</tr>
<tr>
<td>NVMCTRL_DATA_FLASH_Read</td>
<td>Reads length number of bytes from a given address in Data FLASH memory</td>
</tr>
<tr>
<td>NVMCTRL_DATA_FLASH_PageWrite</td>
<td>Writes one page of data to given DATA_FLASH address</td>
</tr>
<tr>
<td>NVMCTRL_DATA_FLASH_RowErase</td>
<td>Erases a Row in the DATA_FLASH</td>
</tr>
<tr>
<td>NVMCTRL_CallbackRegister</td>
<td>Sets the pointer to the function (and it's context) to be called when the operation is complete</td>
</tr>
<tr>
<td>NVMCTRL_CacheInvalidate</td>
<td>Invalidates all cache lines</td>
</tr>
<tr>
<td>NVMCTRL_PageBufferWrite</td>
<td>Writes data to the internal buffer of NVM known as the page buffer</td>
</tr>
<tr>
<td>NVMCTRL_PageBufferCommit</td>
<td>Commits the data present in NVM internal page buffer to flash memory</td>
</tr>
</tbody>
</table>
<table class="data-table">
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>NVMCTRL_FLASH_START_ADDRESS</td>
<td>Macro</td>
<td>Defines the start address of NVMCTRL Flash</td>
</tr>
<tr>
<td>NVMCTRL_FLASH_SIZE</td>
<td>Macro</td>
<td>Defines the size (in bytes) of Flash</td>
</tr>
<tr>
<td>NVMCTRL_FLASH_PAGESIZE</td>
<td>Macro</td>
<td>Defines the size (in bytes) of a NVMCTRL Page</td>
</tr>
<tr>
<td>NVMCTRL_FLASH_ROWSIZE</td>
<td>Macro</td>
<td>Defines the size (in bytes) of a NVMCTRL Row</td>
</tr>
<tr>
<td>NVMCTRL_DATA_FLASH_START_ADDRESS</td>
<td>Macro</td>
<td>Defines the start address of NVMCTRL DATA_FLASH</td>
</tr>
<tr>
<td>NVMCTRL_DATA_FLASH_SIZE</td>
<td>Macro</td>
<td>Defines the size (in bytes) of DATA_FLASH</td>
</tr>
<tr>
<td>NVMCTRL_DATA_FLASH_PAGESIZE</td>
<td>Macro</td>
<td>Defines the size (in bytes) of a NVMCTRL DATA_FLASH Page</td>
</tr>
<tr>
<td>NVMCTRL_DATA_FLASH_ROWSIZE</td>
<td>Macro</td>
<td>Defines the size (in bytes) of a NVMCTRL DATA_FLASH Row</td>
</tr>
<tr>
<td>NVMCTRL_ERROR</td>
<td>Macro</td>
<td>Defines the NVMCTRL Error Type</td>
</tr>
<tr>
<td>NVMCTRL_CALLBACK</td>
<td>Typedef</td>
<td>Defines the data type and function signature for the NVMCTRL peripheral callback function</td>
</tr>
</tbody>
</table>
            </main>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>