<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal Synchronous Asynchronous Receiver Transceiver (USART) | Microchip Documentation</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .sidebar {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            z-index: 100;
            padding: 48px 0 0;
            box-shadow: inset -1px 0 0 rgba(0, 0, 0, .1);
            overflow: hidden;
            width: 280px;
        }

        .nav-frame {
            width: 100%;
            height: 100%;
            border: none;
            overflow-y: scroll;
            overflow-x: hidden;
        }

        .main {
            margin-left: 280px;
            padding: 20px;
        }

        .nav-link {
            color: #333;
            padding: .5rem 1rem;
        }

        .nav-link.active {
            background-color: #f8f9fa;
            font-weight: 500;
        }

        .parameters-table {
            width: 100%;
            margin-bottom: 1rem;
            background-color: #f8f9fa;
        }
    </style>
</head>

<body>
    <div class="container-fluid">
        <div class="row">
            <nav class="sidebar">
                <iframe class="nav-frame" src="navigation.html" title="Navigation"></iframe>
            </nav>
            <main class="main">
<div class="doc-navigation">
    <a href="section_3.38.html">↑ Up to Section</a><br />
    <a href="index.html">↑↑ Back to Main Documentation</a>
</div>

<nav aria-label="breadcrumb">
    <ol class="breadcrumb">
        <li class="breadcrumb-item"><a href="index.html">Home</a></li>
        <li class="breadcrumb-item"><a href="section_3.html">Device Families</a></li>
        <li class="breadcrumb-item"><a href="section_3.38.html">SAM G51 G53 G54 Peripheral Libraries</a></li>
        <li class="breadcrumb-item active" aria-current="page">Universal Synchronous Asynchronous Receiver Transceiver (USART)</li>
    </ol>
</nav>

<h1>Universal Synchronous Asynchronous Receiver Transceiver (USART)</h1>
<h1>3.38.20</h1>
<p>Universal Synchronous Asynchronous Receiver Transceiver (USART)</p>
<p><em>Generated on: 2025-02-19 08:42:44</em></p>
<p>Source: <a href="https://onlinedocs.microchip.com/oxy/GUID-450989FA-38E4-4D68-AB61-15ADB29AD718-en-US-5/GUID-61A3FA86-AF71-4589-91FA-511D82A2F8E8_2.html">https://onlinedocs.microchip.com/oxy/GUID-450989FA-38E4-4D68-AB61-15ADB29AD718-en-US-5/GUID-61A3FA86-AF71-4589-91FA-511D82A2F8E8_2.html</a></p>
<h1>3.38.20 Universal Synchronous Asynchronous Receiver Transceiver (USART)</h1>
<p>The USART peripheral library (PLIB) can be configured either in blocking (interrupt disabled), non-blocking (interrupt enabled) or ring buffer mode. It can also be configured to work as SPI in either blocking (interrupt disabled) or non-blocking (interrupt enabled) mode.</p>
<p>USART Mode</p>
<p>Blocking mode</p>
<p>In blocking mode, the USART peripheral interrupts are disabled and the transfer APIs block until the requested data is transferred.</p>
<p>Non-blocking mode</p>
<p>In non-blocking mode the peripheral interrupt is enabled. The transfer API initiates the transfer and returns immediately. The transfer is then completed from the peripheral interrupt. Application can either use a callback to get notified when the transfer is complete or can use the IsBusy API to check the completion status.</p>
<p>Ring buffer mode</p>
<p>MCCIn ring buffer mode, the receiver is always enabled, and the received data is saved in the internal receive ring buffer, size of which can be configured using MCC. The application can use the API calls to read the data out from the ring buffer. APIs are provided to query the number of (unread) bytes available in the receive buffer, free space in the receive buffer and size of the receive buffer. Similarly, during transmission, the application data is deep copied into the internal transmit ring buffer, size of which can be configured using MCC. This allows the use of local buffers for data transmission. APIs are provided to query the free space in the transmit buffer, number of bytes pending transmission and the size of the transmit buffer. Additionally, application can enable notifications to get notified when n bytes are available in the receive buffer or when n bytes of free space is available in the transmit buffer. The APIs allow application to set the threshold levels for notification in both receive and transmit buffers. Further, application can also choose to enable persistent notifications, whereby the application is notified until the threshold condition is met.</p>
<p>In all the modes, library provides API to change the baud, parity, data width and the number of stop bits at run time.</p>
<h2>Using The Library</h2>
<p>Blocking Mode</p>
<p>Non-blocking Mode</p>
<p>Ring buffer Mode</p>
<p>SPI Mode</p>
<p>The SPI PLIB supports master mode</p>
<p>SPI master mode</p>
<p>In SPI master mode, the PLIB can be configured to run in blocking mode or non-blocking mode. In blocking mode the peripheral interrupt is disabled and the transfer API blocks until the transfer is complete. In non-blocking mode, the peripheral interrupt is enabled. The transfer API initiates the transfer and returns immediately. The transfer is completed from the peripheral interrupt. Application can either use a callback to get notified when the transfer is complete or can use the IsBusy API to check the completion status.</p>
<p>SPI Master in blocking (peripheral interrupt disabled) mode</p>
<p>SPI Master in non-blocking (peripheral interrupt enabled) mode</p>
<p>```C</p>
<h1>define RX_BUFFER_SIZE 10</h1>
<p>char message[] = "USART Example in blocking mode";
char receiveBuffer[RX_BUFFER_SIZE] = {0};
USART_ERROR errorStatus;
char rxData = 0;</p>
<p>int main ( void )
{  <br/>
    /<em> Initialize all modules </em>/
    SYS_Initialize ( NULL );</p>
<pre class="code-block"><code class="language-c">/* Transmit buffer*/
USART1_Write(message, sizeof(message));

/* Wait for a character to be received */
while(USART1_ReceiverIsReady() == false);

if(USART1_ErrorGet() == USART_ERROR_NONE)
{
    /* Read a byte */
    rxData = USART1_ReadByte();
}

/* Receive buffer */
if (USART1_Read(receiveBuffer, RX_BUFFER_SIZE)) == false)
{
    /* Read failed, get the error */
    errorStatus USART1_ErrorGet();

    /* Handle the error */
}
else
{
    /* Transmit the received buffer*/
    USART1_Write(receiveBuffer, RX_BUFFER_SIZE);
}

...

/* Execution should not come here during normal operation */

return ( EXIT_FAILURE );
</code></pre>
<p>}
```</p>
<p>```C</p>
<h1>define RX_BUFFER_SIZE 10</h1>
<p>char message[] = "<strong><em>* Non-blocking Transfer with the interrupt  </em></strong><em>\r\n\
</em><strong><em> Type 10 characters. The received characters are echoed back </em></strong>*\r\n";</p>
<p>char messageError[] = "<strong><em>* USART error occurred </em></strong>*\r\n";</p>
<p>char receiveBuffer[RX_BUFFER_SIZE] = {0};
char echoBuffer[RX_BUFFER_SIZE+4] = {0};</p>
<p>bool errorStatus = false;
bool writeStatus = false;
bool readStatus = false;</p>
<p>void APP_WriteCallback(uintptr_t context)
{
    writeStatus = true;
}</p>
<p>void APP_ReadCallback(uintptr_t context)
{
    if(USART1_ErrorGet() != USART_ERROR_NONE)
    {
        /<em> ErrorGet clears errors, set error flag to notify console </em>/
        errorStatus = true;
    }
    else
    {
        readStatus = true;
    }
}</p>
<p>int main ( void )
{
    /<em> Initialize all modules </em>/
    SYS_Initialize ( NULL );</p>
<pre class="code-block"><code class="language-c">/* Register callback functions and send start message */
USART1_WriteCallbackRegister(APP_WriteCallback, 0);
USART1_ReadCallbackRegister(APP_ReadCallback, 0);
USART1_Write(&amp;message[0], sizeof(message));

while ( true )
{
    if(errorStatus == true)
    {
        /* Send error message to console */
        errorStatus = false;
        USART1_Write(&amp;messageError[0], sizeof(messageError));
    }
    else if(readStatus == true)
    {
        /* Echo back received buffer and Toggle LED */
        readStatus = false;

        echoBuffer[0] = '\n';
        echoBuffer[1] = '\r';
        memcpy(&amp;echoBuffer[2], receiveBuffer,sizeof(receiveBuffer));
        echoBuffer[RX_BUFFER_SIZE+2] = '\n';
        echoBuffer[RX_BUFFER_SIZE+3] = '\r';

        USART1_Write(&amp;echoBuffer[0], sizeof(echoBuffer));
    }
    else if(writeStatus == true)
    {
        /* Submit buffer to read user data */
        writeStatus = false;
        USART1_Read(&amp;receiveBuffer[0], sizeof(receiveBuffer));
    }
    else
    {
        /* Repeat the loop */
        ;
    }
}

/* Execution should not come here during normal operation */

return ( EXIT_FAILURE );
</code></pre>
<p>}
```</p>
<p>```C
uint8_t txBuffer[50];
uint8_t rxBuffer[10];
volatile uint32_t nBytesRead = 0;
volatile bool txThresholdEventReceived = false;
volatile bool rxThresholdEventReceived = false;</p>
<p>void USARTReadEventHandler(USART_EVENT event, uintptr_t context )
{
    uint32_t nBytesAvailable = 0;</p>
<pre class="code-block"><code class="language-c">if (event == USART_EVENT_READ_THRESHOLD_REACHED)
{
    /* Receiver should atleast have the thershold number of bytes in the ring buffer */
    nBytesAvailable = USART1_ReadCountGet();

    nBytesRead += USART1_Read((uint8_t*)&amp;rxBuffer[nBytesRead], nBytesAvailable);                          
}
</code></pre>
<p>}</p>
<p>void USARTWriteEventHandler(USART_EVENT event, uintptr_t context )
{
    txThresholdEventReceived = true;
}</p>
<p>int main ( void )
{
    uint32_t nBytes = 0;        </p>
<pre class="code-block"><code class="language-c">/* Initialize all modules */
SYS_Initialize ( NULL );

/* Register a callback for write events */
USART1_WriteCallbackRegister(USARTWriteEventHandler, (uintptr_t) NULL);

/* Register a callback for read events */
USART1_ReadCallbackRegister(USARTReadEventHandler, (uintptr_t) NULL);

/* Print the size of the read buffer on the terminal */
nBytes = sprintf((char*)txBuffer, "RX Buffer Size = %d\r\n", (int)USART1_ReadBufferSizeGet());

USART1_Write((uint8_t*)txBuffer, nBytes);

/* Print the size of the write buffer on the terminal */
nBytes = sprintf((char*)txBuffer, "TX Buffer Size = %d\r\n", (int)USART1_WriteBufferSizeGet());

USART1_Write((uint8_t*)txBuffer, nBytes);

USART1_Write((uint8_t*)"Adding 10 characters to the TX buffer - ", sizeof("Adding 10 characters to the TX buffer - "));

/* Wait for all bytes to be transmitted out */
while (USART1_WriteCountGet() != 0);

USART1_Write((uint8_t*)"0123456789", 10);

/* Print the amount of free space available in the TX buffer. This should be 10 bytes less than the configured write buffer size. */
nBytes = sprintf((char*)txBuffer, "\r\nFree Space in Transmit Buffer = %d\r\n", (int)USART1_WriteFreeBufferCountGet());

USART1_Write((uint8_t*)txBuffer, nBytes);

/* Let's enable notifications to get notified when the TX buffer is empty */
USART1_WriteThresholdSet(USART1_WriteBufferSizeGet());

/* Enable notifications */
USART1_WriteNotificationEnable(true, false);

/* Wait for the TX buffer to become empty. Flag "txThresholdEventReceived" is set in the callback. */
while (txThresholdEventReceived == false);

txThresholdEventReceived = false;

/* Disable TX notifications */
USART1_WriteNotificationEnable(false, false);

USART1_Write((uint8_t*)"Enter 10 characters. The received characters are echoed back. \r\n&gt;", sizeof("Enter 10 characters. The received characters are echoed back. \r\n&gt;"));

/* Wait till 10 (or more) characters are received */
while (USART1_ReadCountGet() &lt; 10);

/* At-least 10 characters are available in the RX buffer. Read out into the application buffer */
USART1_Read((uint8_t*)rxBuffer, 10);

/* Echo the received data */
USART1_Write((uint8_t*)rxBuffer, 10);

/* Now demonstrating receiver notifications */
USART1_Write((uint8_t*)"\r\n Now turning on RX notifications \r\n&gt;", sizeof("\r\n Now turning on RX notifications \r\n&gt;"));

/* For demonstration purpose, set a threshold value to receive a callback after every 5 characters are received */
USART1_ReadThresholdSet(5);

/* Enable RX event notifications */
USART1_ReadNotificationEnable(true, false);

while(1)
{
    /* Wait until at-least 10 characters are entered by the user */
    while (nBytesRead &lt; 10);

    /* Echo the received data */
    USART1_Write((uint8_t*)rxBuffer, nBytesRead);

    USART1_Write((uint8_t*)"\r\n&gt;", 3);

    nBytesRead = 0;
}

/* Execution should not come here during normal operation */

return ( EXIT_FAILURE );
</code></pre>
<p>}
```</p>
<p>```C
// Following code demonstrates SPI self loopback with the PLIB configured in blocking mode
uint8_t txData[]  = "SELF LOOPBACK FOR SPI!";
uint8_t rxData[sizeof(txData)];</p>
<p>int main ( void )
{
    /<em> Initialize all modules </em>/
    SYS_Initialize ( NULL );</p>
<pre class="code-block"><code class="language-c">/* SPI Write Read */
USART1_SPI_WriteRead(&amp;txData[0], sizeof(txData), &amp;rxData[0], sizeof(rxData));

/* Compare received data with the transmitted data */
if ((memcmp(txData, rxData, sizeof(txData)) == 0))
{
    /* Pass: Received data is same as transmitted data */        
}
else
{       
    /* Fail: Received data is not same as transmitted data */
}

while ( true )
{   
}

/* Execution should not come here during normal operation */

return ( EXIT_FAILURE );
</code></pre>
<p>}
```</p>
<p>```C
// Following code demonstrates SPI self loopback with the PLIB configured in non-blocking mode</p>
<p>uint8_t txData[]  = "SELF LOOPBACK FOR SPI!";
uint8_t rxData[sizeof(txData)];
volatile bool transferStatus = false;</p>
<p>/<em> This function will be called by SPI PLIB when transfer is completed </em>/
void APP_SPI_Callback(uintptr_t context )
{
    transferStatus = true;
}</p>
<p>int main ( void )
{
    /<em> Initialize all modules </em>/
    SYS_Initialize ( NULL );</p>
<pre class="code-block"><code class="language-c">/* Register callback function   */
USART1_SPI_CallbackRegister(APP_SPI_Callback, 0);

/* SPI Write Read */
USART1_SPI_WriteRead(&amp;txData[0], sizeof(txData), &amp;rxData[0], sizeof(rxData));

while (1)
{
    /* Perform other tasks here ...*/

    /* Check if transfer has completed */
    if(transferStatus == true)
    {
        /* Compare received data with the transmitted data */
        if(memcmp(txData, rxData, sizeof(txData)) == 0)
        {
            /* Pass: Received data is same as transmitted data */       
        }
        else
        {   
            /* Fail: Received data is not same as transmitted data */       
        }   
    }               
}
</code></pre>
<p>}
```</p>
<h2>Library Interface</h2>
<p>USART peripheral library provides the following interfaces:</p>
<p>USART Mode</p>
<p>Functions</p>
<p>Data types and constants</p>
<p>SPI Mode</p>
<p>Functions</p>
<p>Data types and constants</p>
<p>LIN Mode</p>
<p>Functions</p>
<p>Data types and constants</p>
<table class="data-table">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Blocking mode</th>
<th>Non-blocking mode</th>
<th>Ring buffer mode</th>
</tr>
</thead>
<tbody>
<tr>
<td>USARTx_Initialize</td>
<td>Initializes given instance of the USART peripheral</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_SerialSetup</td>
<td>Sets up serial configurations for USART peripheral</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_Write</td>
<td>Writes data to the given USART peripheral instance</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_Read</td>
<td>Reads data from the given USART peripheral instance</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_WriteIsBusy</td>
<td>Returns the write request status associated with the given USART peripheral instance</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>USARTx_ReadIsBusy</td>
<td>Returns the read request status associated with the given USART peripheral instance</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>USARTx_WriteCountGet</td>
<td>Gets the byte count of processed bytes for a given USART read operation in non-blocking mode. Returns the number of bytes pending to be transmitted out in the transmit buffer in ring buffer mode.</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_ReadCountGet</td>
<td>Gets the byte count of processed bytes for a given USART read operation in non-blocking mode. Returns the number of bytes available in the internal receive buffer of the PLIB in ring buffer mode.</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_TransmitterIsReady</td>
<td>Returns the hardware status of the USART Transmitter</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>USARTx_ReceiverIsReady</td>
<td>Returns the hardware status of the USART Receiver</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>USARTx_ErrorGet</td>
<td>Gets the error of the given USART peripheral instance</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_WriteCallbackRegister</td>
<td>Sets the pointer to the function (and it's context) to be called when the given USART's write events occur</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_ReadCallbackRegister</td>
<td>Sets the pointer to the function (and it's context) to be called when the given USART's read events occur</td>
<td>No</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_ReadByte</td>
<td>Submits request to read a byte of data to the given USART peripheral</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>USARTx_WriteByte</td>
<td>Submits a byte of data to the given USART peripheral to transfer</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>USARTx_ReadAbort</td>
<td>Aborts the ongoing read request</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>USARTx_WriteFreeBufferCountGet</td>
<td>Returns the number of bytes of free space available in the internal transmit buffer</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_WriteBufferSizeGet</td>
<td>Returns the size of the internal transmit ring buffer</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_WriteNotificationEnable</td>
<td>This API lets the application turn the transmit notifications on/off</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_WriteThresholdSet</td>
<td>This API allows the application to set a threshold level on the number of free space available in the transmit buffer</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_ReadFreeBufferCountGet</td>
<td>Returns the number of bytes of free space available in the internal receive buffer</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_ReadBufferSizeGet</td>
<td>Returns the size of the receive ring buffer</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_ReadNotificationEnable</td>
<td>This API lets the application turn the receive notifications on/off</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_ReadThresholdSet</td>
<td>This API allows the application to set a threshold level on the number of bytes of data available in the receive buffer</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<table class="data-table">
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Blocking mode</th>
<th>Non-blocking mode</th>
<th>Ring buffer mode</th>
</tr>
</thead>
<tbody>
<tr>
<td>USART_ERROR</td>
<td>Macros and Typedef</td>
<td>Defines the macros and typedefs associated with the USART peripheral errors</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USART_DATA</td>
<td>Enum</td>
<td>Defines the data width types for the USART peripheral</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USART_PARITY</td>
<td>Enum</td>
<td>Defines the parity types for the USART peripheral</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USART_STOP</td>
<td>Enum</td>
<td>Defines the data type for the USART peripheral stop bits</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USART_SERIAL_SETUP</td>
<td>Struct</td>
<td>Defines the data structure which is used to configure USART serial parameters at run time</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USART_CALLBACK</td>
<td>Typedef</td>
<td>Defines the data type and function signature of the USART peripheral library callback function</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>USART_EVENT</td>
<td>Enum</td>
<td>Defines the enums associated with the USART events in the ring buffer mode</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USART_RING_BUFFER_CALLBACK</td>
<td>Typedef</td>
<td>Defines the data type and function signature for the USART peripheral callback function in the ring buffer mode</td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<table class="data-table">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Master (blocking/interrupt disabled) mode</th>
<th>Master (non-blocking/interrupt enabled) mode</th>
</tr>
</thead>
<tbody>
<tr>
<td>USARTx_SPI_Initialize</td>
<td>Initializes USART peripheral in SPI mode</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_SPI_TransferSetup</td>
<td>Configure SPI operational parameters at run time</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_SPI_WriteRead</td>
<td>Write and Read data on SPI peripheral</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_SPI_Write</td>
<td>Writes data to SPI peripheral</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_SPI_Read</td>
<td>Reads data on the SPI peripheral</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_SPI_CallbackRegister</td>
<td>Allows application to register a callback with the PLIB</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_SPI_IsBusy</td>
<td>Returns transfer status of SPI</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<table class="data-table">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Master (blocking/interrupt disabled) mode</th>
<th>Master (non-blocking/interrupt enabled) mode</th>
</tr>
</thead>
<tbody>
<tr>
<td>USART_SPI_CLOCK_PHASE</td>
<td>Enum</td>
<td>Identifies SPI Clock Phase Options</td>
<td>Yes</td>
</tr>
<tr>
<td>USART_SPI_CLOCK_POLARITY</td>
<td>Enum</td>
<td>Identifies SPI Clock Polarity Options</td>
<td>Yes</td>
</tr>
<tr>
<td>USART_SPI_DATA_BITS</td>
<td>Enum</td>
<td>Identifies SPI bits per transfer</td>
<td>Yes</td>
</tr>
<tr>
<td>USART_SPI_TRANSFER_SETUP</td>
<td>Struct</td>
<td>Data structure containing the SPI parameters which can be changed at run time</td>
<td>Yes</td>
</tr>
<tr>
<td>USART_SPI_CALLBACK</td>
<td>Typedef</td>
<td>Defines the data type and function signature for the USART SPI peripheral callback function</td>
<td>No</td>
</tr>
</tbody>
</table>
<table class="data-table">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Host (blocking/interrupt disabled) mode</th>
<th>Host (non-blocking/interrupt enabled) mode</th>
<th>Client (blocking/interrupt disabled) mode</th>
<th>Client (non-blocking/interrupt enabled) mode</th>
</tr>
</thead>
<tbody>
<tr>
<td>USARTx_LIN_ChecksumEnable Function</td>
<td>Enables hardware checksum for data transfer</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_LIN_ChecksumTypeSet Function</td>
<td>Set the type of checksum to be used during data</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>transfer.</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>USARTx_LIN_DataLenModeSet Function</td>
<td>Set Data Length Mode</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_LIN_FrameSlotEnable Function</td>
<td>Enable/Disable Frame Slot Mode</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td>USARTx_LIN_IdentifierRead Function</td>
<td>Helps the application to read LIN ID to corresponding</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>hardware register</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>USARTx_LIN_IdentifierWrite Function</td>
<td>Helps the application to write LIN ID to corresponding</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>hardware register</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>USARTx_LIN_NodeActionSet Function</td>
<td>Allows to set the Action to be performed by LIN Node</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>(PUBLISH, SUBSCRIBE or IGNORE)</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>USARTx_LIN_ParityEnable Function</td>
<td>Allows to Enable/Disable LIN Identifier parity</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>mode</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>USARTx_LIN_ResponseDataLenSet</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Function</td>
<td>Allowas to set the data length to be transferred</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
</tr>
<tr>
<td>USARTx_LIN_TransferComplete Function</td>
<td>Allows to check if the requested data transfer is</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>completed or not</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>USARTx_LINBreakCallbackRegister</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Function</td>
<td>Allows  to register a callback function for the PLIB to</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>call back when the Break Field of the requested LIN header transfer</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>operation has completed.</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>USARTx_LINIdCallbackRegister</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Function</td>
<td>Allows to register a callback function for the PLIB to</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>call back when the requested LIN ID transfer operation has</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>completed.</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>USARTx_LINTcCallbackRegister</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Function</td>
<td>Allows to register a callback function for the PLIB to call back when</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>the requested LIN data transfer operation has completed</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td></td>
</tr>
</tbody>
</table>
<table class="data-table">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
<th>Master (blocking/interrupt disabled) mode</th>
<th>Master (non-blocking/interrupt enabled) mode</th>
<th>Client (blocking/interrupt disabled) mode</th>
<th>Client (non-blocking/interrupt enabled) mode</th>
</tr>
</thead>
<tbody>
<tr>
<td>USART_LIN_CALLBACK Typedef</td>
<td>Defines the data type and function signature for the</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>USART LIN peripheral callback function.</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>USART_LIN_CHECKSUM_TYPE Enum</td>
<td>Defines the data type for the USART LIN checksum type</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>bits</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>USART_LIN_DATA_LEN Enum</td>
<td>Defines the data type for the USART LIN Data Length Mode</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>bits</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
<tr>
<td>USART_LIN_NACT Enum</td>
<td>Defines the data type for the USART LIN node action</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>bits</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td>Yes</td>
<td></td>
</tr>
</tbody>
</table>
            </main>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>