<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Control Area Network (CAN) | Microchip Documentation</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .sidebar {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            z-index: 100;
            padding: 48px 0 0;
            box-shadow: inset -1px 0 0 rgba(0, 0, 0, .1);
            overflow: hidden;
            width: 280px;
        }

        .nav-frame {
            width: 100%;
            height: 100%;
            border: none;
            overflow-y: scroll;
            overflow-x: hidden;
        }

        .main {
            margin-left: 280px;
            padding: 20px;
        }

        .nav-link {
            color: #333;
            padding: .5rem 1rem;
        }

        .nav-link.active {
            background-color: #f8f9fa;
            font-weight: 500;
        }

        .parameters-table {
            width: 100%;
            margin-bottom: 1rem;
            background-color: #f8f9fa;
        }
    </style>
</head>

<body>
    <div class="container-fluid">
        <div class="row">
            <nav class="sidebar">
                <iframe class="nav-frame" src="navigation.html" title="Navigation"></iframe>
            </nav>
            <main class="main">
<div class="doc-navigation">
    <a href="section_3.12.html">↑ Up to Section</a><br />
    <a href="index.html">↑↑ Back to Main Documentation</a>
</div>

<nav aria-label="breadcrumb">
    <ol class="breadcrumb">
        <li class="breadcrumb-item"><a href="index.html">Home</a></li>
        <li class="breadcrumb-item"><a href="section_3.html">Device Families</a></li>
        <li class="breadcrumb-item"><a href="section_3.12.html">PIC32CZ-CA Peripheral Libraries</a></li>
        <li class="breadcrumb-item active" aria-current="page">Control Area Network (CAN)</li>
    </ol>
</nav>

<h1>Control Area Network (CAN)</h1>
<h1>3.12.2</h1>
<p>Control Area Network (CAN)</p>
<p><em>Generated on: 2025-02-19 08:42:44</em></p>
<p>Source: <a href="https://onlinedocs.microchip.com/oxy/GUID-450989FA-38E4-4D68-AB61-15ADB29AD718-en-US-5/GUID-DD671C66-9CDA-4EBE-9DBC-CD94401F6D76_3.html">https://onlinedocs.microchip.com/oxy/GUID-450989FA-38E4-4D68-AB61-15ADB29AD718-en-US-5/GUID-DD671C66-9CDA-4EBE-9DBC-CD94401F6D76_3.html</a></p>
<h1>3.12.2 Control Area Network (CAN)</h1>
<p>The Controller Area Network (CAN) performs communication according to
ISO 11898-1:2015 and to Bosch CAN-FD specification. Additional
transceiver hardware is required for connection to the physical layer.</p>
<p>All functions concerning the handling of messages are implemented by
the Rx Handler and the Tx Handler. The Rx Handler manages message
acceptance filtering, the transfer of received messages from the CAN
core to the Message RAM, as well as providing receive message status
information. The Tx Handler is responsible for the transfer of transmit
messages from the Message RAM to the CAN core, as well as providing
transmit status information. Acceptance filtering is implemented by a
combination of up to 128 filter elements, where each element can be
configured as a range, as a bit mask, or as a dedicated ID filter.</p>
<p>Using The Library</p>
<p>The CAN library supports the Normal and CAN-FD modes. The CAN Normal or
CAN-FD mode can transfer message in a polling or an interrupt mode.</p>
<p>CAN Message RAM Configuration</p>
<p>Allocate CAN Message RAM Configuration in contiguous non-cacheable
buffer as uint8_t Can1MessageRAM"CAN1_MESSAGE_RAM_CONFIG_SIZE"
      attribute((aligned (32))), here additional attribute such as
attribute((section(".region_nocache"))) or
attribute((space(data), section (".ram_nocache"))) should be added
if cache is enabled and non-cacheable section should be created in
linker script.</p>
<p>CAN polling mode:</p>
<p>CAN interrupt mode:</p>
<p>Library Interface</p>
<p>Control Area Network peripheral library provides the following interfaces:</p>
<p>Functions</p>
<p>Data types and constants</p>
<p>```C</p>
<h1>include <stddef.h>                     // Defines NULL</stddef.h></h1>
<h1>include <stdbool.h>                    // Defines true</stdbool.h></h1>
<h1>include <stdlib.h>                     // Defines EXIT_FAILURE</stdlib.h></h1>
<h1>include "definitions.h"                // SYS function prototypes</h1>
<p>uint8_t Can1MessageRAM[CAN1_MESSAGE_RAM_CONFIG_SIZE] <strong>attribute</strong>((aligned (32)));</p>
<p>/<em> Standard identifier id[28:18]</em>/</p>
<h1>define WRITE_ID(id) (id &lt;&lt; 18)</h1>
<h1>define READ_ID(id)  (id &gt;&gt; 18)</h1>
<p>static uint32_t status = 0;
static uint8_t loop_count = 0;
static uint8_t user_input = 0;</p>
<p>static uint8_t txFiFo[CAN1_TX_FIFO_BUFFER_SIZE];
static uint8_t rxFiFo0[CAN1_RX_FIFO0_SIZE];
static uint8_t rxFiFo1[CAN1_RX_FIFO1_SIZE];
static uint8_t rxBuffer[CAN1_RX_BUFFER_SIZE];</p>
<p>// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// Section: Local functions
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong></p>
<p>/<em> Message Length to Data length code </em>/
static uint8_t CANLengthToDlcGet(uint8_t length)
{
    uint8_t dlc = 0;</p>
<pre class="code-block"><code class="language-c">if (length &lt;= 8U)
{
    dlc = length;
}
else if (length &lt;= 12U)
{
    dlc = 0x9U;
}
else if (length &lt;= 16U)
{
    dlc = 0xAU;
}
else if (length &lt;= 20U)
{
    dlc = 0xBU;
}
else if (length &lt;= 24U)
{
    dlc = 0xCU;
}
else if (length &lt;= 32U)
{
    dlc = 0xDU;
}
else if (length &lt;= 48U)
{
    dlc = 0xEU;
}
else
{
    dlc = 0xFU;
}
return dlc;
</code></pre>
<p>}</p>
<p>/<em> Data length code to Message Length </em>/
static uint8_t CANDlcToLengthGet(uint8_t dlc)
{
    uint8_t msgLength[] = {0U, 1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 12U, 16U, 20U, 24U, 32U, 48U, 64U};
    return msgLength[dlc];
}</p>
<p>/<em> Menu </em>/
static void display_menu(void)
{
    printf("Menu :\r\n"
           "  -- Select the action:\r\n"
           "  0: Send FD standard message with ID: 0x45A and 64 byte data 0 to 63. \r\n"
           "  1: Send FD standard message with ID: 0x469 and 64 byte data 128 to 191. \r\n"
           "  2: Send FD extended message with ID: 0x100000A5 and 64 byte data 0 to 63. \r\n"
           "  3: Send FD extended message with ID: 0x10000096 and 64 byte data 128 to 191. \r\n"
           "  4: Send normal standard message with ID: 0x469 and 8 byte data 0 to 7. \r\n"
           "  m: Display menu \r\n\r\n");
}</p>
<p>/<em> Print Rx Message </em>/
static void print_message(uint8_t numberOfMessage, CAN_RX_BUFFER *rxBuf, uint8_t rxBufLen, uint8_t rxFifoBuf)
{
    uint8_t length = 0;
    uint8_t msgLength = 0;
    uint32_t id = 0;</p>
<pre class="code-block"><code class="language-c">if (rxFifoBuf == 0)
    printf(" Rx FIFO0 :");
else if (rxFifoBuf == 1)
    printf(" Rx FIFO1 :");
else if (rxFifoBuf == 2)
    printf(" Rx Buffer :");

for (uint8_t count = 0; count &lt; numberOfMessage; count++)
{
    /* Print message to Console */
    printf(" New Message Received\r\n");
    id = rxBuf-&gt;xtd ? rxBuf-&gt;id : READ_ID(rxBuf-&gt;id);
    msgLength = CANDlcToLengthGet(rxBuf-&gt;dlc);
    length = msgLength;
    printf(" Message - ID : 0x%x Length : 0x%x ", (unsigned int)id, (unsigned int)msgLength);
    printf("Message : ");
    while(length)
    {
        printf("0x%x ", rxBuf-&gt;data[msgLength - length--]);
    }
    printf("\r\n");
    rxBuf += rxBufLen;
}
</code></pre>
<p>}</p>
<p>// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// Section: Main Entry Point
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong></p>
<p>int main ( void )
{
    CAN_TX_BUFFER *txBuffer = NULL;
    uint8_t        bufferNumber = 0;
    uint8_t        numberOfMessage = 0;</p>
<pre class="code-block"><code class="language-c">/* Initialize all modules */
SYS_Initialize ( NULL );

printf(" ------------------------------ \r\n");
printf("            CAN FD Demo          \r\n");
printf(" ------------------------------ \r\n");

/* Set Message RAM Configuration */
CAN1_MessageRAMConfigSet(Can1MessageRAM);

display_menu();

while ( true )
{
    /* Rx Buffers */
    if (CAN1_InterruptGet(CAN_INTERRUPT_DRX_MASK))
    {    
        CAN1_InterruptClear(CAN_INTERRUPT_DRX_MASK);

        /* Check CAN Status */
        status = CAN1_ErrorGet();

        if (((status &amp; CAN_PSR_LEC_Msk) == CAN_ERROR_NONE) || ((status &amp; CAN_PSR_LEC_Msk) == CAN_ERROR_LEC_NC))
        {
            if (CAN1_RxBufferNumberGet(&amp;bufferNumber))
            {
                memset(rxBuffer, 0x00, CAN1_RX_BUFFER_ELEMENT_SIZE);
                if (CAN1_MessageReceive(bufferNumber, (CAN_RX_BUFFER *)rxBuffer) == true)
                {
                    print_message(1, (CAN_RX_BUFFER *)rxBuffer, CAN1_RX_BUFFER_ELEMENT_SIZE, 2);
                }
                else
                {
                    printf(" Error in received message\r\n");
                }
            }
        }
        else
        {
            printf(" Error in received message\r\n");
        }
    }

    /* Rx FIFO0 */
    if (CAN1_InterruptGet(CAN_INTERRUPT_RF0N_MASK))
    {    
        CAN1_InterruptClear(CAN_INTERRUPT_RF0N_MASK);

        /* Check CAN Status */
        status = CAN1_ErrorGet();

        if (((status &amp; CAN_PSR_LEC_Msk) == CAN_ERROR_NONE) || ((status &amp; CAN_PSR_LEC_Msk) == CAN_ERROR_LEC_NC))
        {
            numberOfMessage = CAN1_RxFifoFillLevelGet(CAN_RX_FIFO_0);
            if (numberOfMessage != 0)
            {
                memset(rxFiFo0, 0x00, (numberOfMessage * CAN1_RX_FIFO0_ELEMENT_SIZE));
                if (CAN1_MessageReceiveFifo(CAN_RX_FIFO_0, numberOfMessage, (CAN_RX_BUFFER *)rxFiFo0) == true)
                {
                    print_message(numberOfMessage, (CAN_RX_BUFFER *)rxFiFo0, CAN1_RX_FIFO0_ELEMENT_SIZE, 0);
                }
                else
                {
                    printf(" Error in received message\r\n");
                }
            }
        }
        else
        {
            printf(" Error in received message\r\n");
        }
    }

    /* Rx FIFO1 */
    if (CAN1_InterruptGet(CAN_INTERRUPT_RF1N_MASK))
    {    
        CAN1_InterruptClear(CAN_INTERRUPT_RF1N_MASK);

        /* Check CAN Status */
        status = CAN1_ErrorGet();

        if (((status &amp; CAN_PSR_LEC_Msk) == CAN_ERROR_NONE) || ((status &amp; CAN_PSR_LEC_Msk) == CAN_ERROR_LEC_NC))
        {
            numberOfMessage = CAN1_RxFifoFillLevelGet(CAN_RX_FIFO_1);
            if (numberOfMessage != 0)
            {
                memset(rxFiFo1, 0x00, (numberOfMessage * CAN1_RX_FIFO1_ELEMENT_SIZE));
                if (CAN1_MessageReceiveFifo(CAN_RX_FIFO_1, numberOfMessage, (CAN_RX_BUFFER *)rxFiFo1) == true)
                {
                    print_message(numberOfMessage, (CAN_RX_BUFFER *)rxFiFo1, CAN1_RX_FIFO1_ELEMENT_SIZE, 1);
                }
                else
                {
                    printf(" Error in received message\r\n");
                }
            }
        }
        else
        {
            printf(" Error in received message\r\n");
        }
    }

    /* User input */
    if (SERCOM4_USART_ReceiverIsReady() == false)
    {
        continue;
    }
    user_input = (uint8_t)SERCOM4_USART_ReadByte();

    switch (user_input)
    {
        case '0':
            memset(txFiFo, 0x00, CAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
            txBuffer = (CAN_TX_BUFFER *)txFiFo;
            txBuffer-&gt;id = WRITE_ID(0x45A);
            txBuffer-&gt;dlc = CANLengthToDlcGet(64);
            txBuffer-&gt;fdf = 1;
            txBuffer-&gt;brs = 1;
            for (loop_count = 0; loop_count &lt; 64; loop_count++){
                txBuffer-&gt;data[loop_count] = loop_count;
            }                
            printf("  0: Send FD standard message with ID: 0x45A and 64 byte data 0 to 63.\r\n");
            if (CAN1_MessageTransmitFifo(1, txBuffer) == true)
            {    
                printf(" Success \r\n");
            }
            else
            {
                printf(" Failed \r\n");
            }             
            break;  
        case '1':
            memset(txFiFo, 0x00, CAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
            txBuffer = (CAN_TX_BUFFER *)txFiFo;
            txBuffer-&gt;id = WRITE_ID(0x469);
            txBuffer-&gt;dlc = CANLengthToDlcGet(64);
            txBuffer-&gt;fdf = 1;
            txBuffer-&gt;brs = 1;
            for (loop_count = 128; loop_count &lt; 192; loop_count++){
                txBuffer-&gt;data[loop_count - 128] = loop_count;
            }                
            printf("  1: Send FD standard message with ID: 0x469 and 64 byte data 128 to 191.\r\n");
            if (CAN1_MessageTransmitFifo(1, txBuffer) == true)
            {    
                printf(" Success \r\n");
            }
            else
            {
                printf(" Failed \r\n");
            }    
            break;
        case '2': 
            memset(txFiFo, 0x00, CAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
            txBuffer = (CAN_TX_BUFFER *)txFiFo;
            txBuffer-&gt;id = 0x100000A5;
            txBuffer-&gt;dlc = CANLengthToDlcGet(64);
            txBuffer-&gt;xtd = 1;
            txBuffer-&gt;fdf = 1;
            txBuffer-&gt;brs = 1;
            for (loop_count = 0; loop_count &lt; 64; loop_count++){
                txBuffer-&gt;data[loop_count] = loop_count;
            }
            printf("  2: Send FD extended message with ID: 0x100000A5 and 64 byte data 0 to 63.\r\n");
            if (CAN1_MessageTransmitFifo(1, txBuffer) == true)
            {    
                printf(" Success \r\n");
            }
            else
            {
                printf(" Failed \r\n");
            }             
            break;
        case '3':
            memset(txFiFo, 0x00, CAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
            txBuffer = (CAN_TX_BUFFER *)txFiFo;
            txBuffer-&gt;id = 0x10000096;
            txBuffer-&gt;dlc = CANLengthToDlcGet(64);
            txBuffer-&gt;xtd = 1;
            txBuffer-&gt;fdf = 1;
            txBuffer-&gt;brs = 1;
            for (loop_count = 128; loop_count &lt; 192; loop_count++){
                txBuffer-&gt;data[loop_count - 128] = loop_count;
            }
            printf("  3: Send FD extended message with ID: 0x10000096 and 64 byte data 128 to 191.\r\n");
            if (CAN1_MessageTransmitFifo(1, txBuffer) == true)
            {    
                printf(" Success \r\n");
            }
            else
            {
                printf(" Failed \r\n");
            }             
            break;

        case '4':
            memset(txFiFo, 0x00, CAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
            txBuffer = (CAN_TX_BUFFER *)txFiFo;
            txBuffer-&gt;id = WRITE_ID(0x469);
            txBuffer-&gt;dlc = 8;
            for (loop_count = 0; loop_count &lt; 8; loop_count++){
                txBuffer-&gt;data[loop_count] = loop_count;
            }                
            printf("  4: Send normal standard message with ID: 0x469 and 8 byte data 0 to 7.\r\n");
            if (CAN1_MessageTransmitFifo(1, txBuffer) == true)
            {    
                printf(" Success \r\n");
            }
            else
            {
                printf(" Failed \r\n");
            }             
            break;

        case 'm':
        case 'M':
            display_menu();
            break;

        default:
            printf(" Invalid Input \r\n");
            break;
    }  
}

/* Execution should not come here during normal operation */

return ( EXIT_FAILURE );
</code></pre>
<p>}
```</p>
<p>```C</p>
<h1>include <stddef.h>                     // Defines NULL</stddef.h></h1>
<h1>include <stdbool.h>                    // Defines true</stdbool.h></h1>
<h1>include <stdlib.h>                     // Defines EXIT_FAILURE</stdlib.h></h1>
<h1>include "definitions.h"                // SYS function prototypes</h1>
<p>uint8_t Can1MessageRAM[CAN1_MESSAGE_RAM_CONFIG_SIZE] <strong>attribute</strong>((aligned (32)));</p>
<p>/<em> Standard identifier id[28:18]</em>/</p>
<h1>define WRITE_ID(id) (id &lt;&lt; 18)</h1>
<h1>define READ_ID(id)  (id &gt;&gt; 18)</h1>
<p>/<em> Application's state machine enum </em>/
typedef enum
{
    APP_STATE_CAN_RECEIVE,
    APP_STATE_CAN_TRANSMIT,
    APP_STATE_CAN_IDLE,
    APP_STATE_CAN_XFER_SUCCESSFUL,
    APP_STATE_CAN_XFER_ERROR,
    APP_STATE_CAN_USER_INPUT
} APP_STATES;</p>
<p>/<em> Variable to save Tx/Rx transfer status and context </em>/
static uint32_t status = 0;
static uint32_t xferContext = 0;
/<em> Variable to save Tx/Rx message </em>/
static uint8_t loop_count = 0;
static uint8_t user_input = 0;
/<em> Variable to save application state </em>/
volatile static APP_STATES state = APP_STATE_CAN_USER_INPUT;</p>
<p>static uint8_t txFiFo[CAN1_TX_FIFO_BUFFER_SIZE];
static uint8_t rxFiFo0[CAN1_RX_FIFO0_SIZE];
static uint8_t rxFiFo1[CAN1_RX_FIFO1_SIZE];
static uint8_t rxBuffer[CAN1_RX_BUFFER_SIZE];</p>
<p>// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// Section: Local functions
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong></p>
<p>/<em> Message Length to Data length code </em>/
static uint8_t CANLengthToDlcGet(uint8_t length)
{
    uint8_t dlc = 0;</p>
<pre class="code-block"><code class="language-c">if (length &lt;= 8U)
{
    dlc = length;
}
else if (length &lt;= 12U)
{
    dlc = 0x9U;
}
else if (length &lt;= 16U)
{
    dlc = 0xAU;
}
else if (length &lt;= 20U)
{
    dlc = 0xBU;
}
else if (length &lt;= 24U)
{
    dlc = 0xCU;
}
else if (length &lt;= 32U)
{
    dlc = 0xDU;
}
else if (length &lt;= 48U)
{
    dlc = 0xEU;
}
else
{
    dlc = 0xFU;
}
return dlc;
</code></pre>
<p>}</p>
<p>/<em> Data length code to Message Length </em>/
static uint8_t CANDlcToLengthGet(uint8_t dlc)
{
    uint8_t msgLength[] = {0U, 1U, 2U, 3U, 4U, 5U, 6U, 7U, 8U, 12U, 16U, 20U, 24U, 32U, 48U, 64U};
    return msgLength[dlc];
}</p>
<p>/<em> Menu </em>/
static void display_menu(void)
{
    printf("Menu :\r\n"
           "  -- Select the action:\r\n"
           "  0: Send FD standard message with ID: 0x45A and 64 byte data 0 to 63. \r\n"
           "  1: Send FD standard message with ID: 0x469 and 64 byte data 128 to 191. \r\n"
           "  2: Send FD extended message with ID: 0x100000A5 and 64 byte data 0 to 63. \r\n"
           "  3: Send FD extended message with ID: 0x10000096 and 64 byte data 128 to 191. \r\n"
           "  4: Send normal standard message with ID: 0x469 and 8 byte data 0 to 7. \r\n"
           "  m: Display menu \r\n\r\n");
}</p>
<p>/<em> Print Rx Message </em>/
static void print_message(uint8_t numberOfMessage, CAN_RX_BUFFER *rxBuf, uint8_t rxBufLen, uint8_t rxFifoBuf)
{
    uint8_t length = 0;
    uint8_t msgLength = 0;
    uint32_t id = 0;</p>
<pre class="code-block"><code class="language-c">if (rxFifoBuf == 0)
    printf(" Rx FIFO0 :");
else if (rxFifoBuf == 1)
    printf(" Rx FIFO1 :");
else if (rxFifoBuf == 2)
    printf(" Rx Buffer :");

for (uint8_t count = 0; count &lt; numberOfMessage; count++)
{
    /* Print message to Console */
    printf(" New Message Received\r\n");
    id = rxBuf-&gt;xtd ? rxBuf-&gt;id : READ_ID(rxBuf-&gt;id);
    msgLength = CANDlcToLengthGet(rxBuf-&gt;dlc);
    length = msgLength;
    printf(" Message - Timestamp : 0x%x ID : 0x%x Length : 0x%x ", (unsigned int)rxBuf-&gt;rxts, (unsigned int)id, (unsigned int)msgLength);
    printf("Message : ");
    while(length)
    {
        printf("0x%x ", rxBuf-&gt;data[msgLength - length--]);
    }
    printf("\r\n");
    rxBuf += rxBufLen;
}
</code></pre>
<p>}</p>
<p>/<em> This function will be called by CAN PLIB when transfer is completed from Tx FIFO </em>/
void APP_CAN_TxFifoCallback(uintptr_t context)
{
    xferContext = context;</p>
<pre class="code-block"><code class="language-c">/* Check CAN Status */
status = CAN1_ErrorGet();

if (((status &amp; CAN_PSR_LEC_Msk) == CAN_ERROR_NONE) || ((status &amp; CAN_PSR_LEC_Msk) == CAN_ERROR_LEC_NC))
{
    switch ((APP_STATES)context)
    {
        case APP_STATE_CAN_TRANSMIT:
        {
            state = APP_STATE_CAN_XFER_SUCCESSFUL;
            break;
        }
        default:
            break;
    }
}
else
{
    state = APP_STATE_CAN_XFER_ERROR;
}
</code></pre>
<p>}</p>
<p>/<em> This function will be called by CAN PLIB when Message received in Rx Buffer </em>/
void APP_CAN_RxBufferCallback(uint8_t bufferNumber, uintptr_t context)
{
    xferContext = context;</p>
<pre class="code-block"><code class="language-c">/* Check CAN Status */
status = CAN1_ErrorGet();

if (((status &amp; CAN_PSR_LEC_Msk) == CAN_ERROR_NONE) || ((status &amp; CAN_PSR_LEC_Msk) == CAN_ERROR_LEC_NC))
{
    switch ((APP_STATES)context)
    {
        case APP_STATE_CAN_RECEIVE:
        {
            memset(rxBuffer, 0x00, CAN1_RX_BUFFER_ELEMENT_SIZE);
            if (CAN1_MessageReceive(bufferNumber, (CAN_RX_BUFFER *)rxBuffer) == true)
            {
                print_message(1, (CAN_RX_BUFFER *)rxBuffer, CAN1_RX_BUFFER_ELEMENT_SIZE, 2);
                state = APP_STATE_CAN_XFER_SUCCESSFUL;
            }
            else
            {
                state = APP_STATE_CAN_XFER_ERROR;
            }
            break;
        }
        default:
            break;
    }
}
else
{
    state = APP_STATE_CAN_XFER_ERROR;
}
</code></pre>
<p>}</p>
<p>/<em> This function will be called by CAN PLIB when Message received in Rx FIFO0 </em>/
void APP_CAN_RxFifo0Callback(uint8_t numberOfMessage, uintptr_t context)
{
    xferContext = context;</p>
<pre class="code-block"><code class="language-c">/* Check CAN Status */
status = CAN1_ErrorGet();

if (((status &amp; CAN_PSR_LEC_Msk) == CAN_ERROR_NONE) || ((status &amp; CAN_PSR_LEC_Msk) == CAN_ERROR_LEC_NC))
{
    switch ((APP_STATES)context)
    {
        case APP_STATE_CAN_RECEIVE:
        {
            memset(rxFiFo0, 0x00, (numberOfMessage * CAN1_RX_FIFO0_ELEMENT_SIZE));
            if (CAN1_MessageReceiveFifo(CAN_RX_FIFO_0, numberOfMessage, (CAN_RX_BUFFER *)rxFiFo0) == true)
            {
                print_message(numberOfMessage, (CAN_RX_BUFFER *)rxFiFo0, CAN1_RX_FIFO0_ELEMENT_SIZE, 0);
                state = APP_STATE_CAN_XFER_SUCCESSFUL;
            }
            else
            {
                state = APP_STATE_CAN_XFER_ERROR;
            }
            break;
        }
        default:
            break;
    }
}
else
{
    state = APP_STATE_CAN_XFER_ERROR;
}
</code></pre>
<p>}</p>
<p>/<em> This function will be called by CAN PLIB when Message received in Rx FIFO1 </em>/
void APP_CAN_RxFifo1Callback(uint8_t numberOfMessage, uintptr_t context)
{
    xferContext = context;</p>
<pre class="code-block"><code class="language-c">/* Check CAN Status */
status = CAN1_ErrorGet();

if (((status &amp; CAN_PSR_LEC_Msk) == CAN_ERROR_NONE) || ((status &amp; CAN_PSR_LEC_Msk) == CAN_ERROR_LEC_NC))
{
    switch ((APP_STATES)context)
    {
        case APP_STATE_CAN_RECEIVE:
        {
            memset(rxFiFo1, 0x00, (numberOfMessage * CAN1_RX_FIFO1_ELEMENT_SIZE));
            if (CAN1_MessageReceiveFifo(CAN_RX_FIFO_1, numberOfMessage, (CAN_RX_BUFFER *)rxFiFo1) == true)
            {
                print_message(numberOfMessage, (CAN_RX_BUFFER *)rxFiFo1, CAN1_RX_FIFO1_ELEMENT_SIZE, 1);
                state = APP_STATE_CAN_XFER_SUCCESSFUL;
            }
            else
            {
                state = APP_STATE_CAN_XFER_ERROR;
            }
            break;
        }
        default:
            break;
    }
}
else
{
    state = APP_STATE_CAN_XFER_ERROR;
}
</code></pre>
<p>}</p>
<p>// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// Section: Main Entry Point
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong>
// <strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong><strong><em>*</em></strong></p>
<p>int main ( void )
{
    CAN_TX_BUFFER *txBuffer = NULL;</p>
<pre class="code-block"><code class="language-c">/* Initialize all modules */
SYS_Initialize ( NULL );

printf(" ------------------------------ \r\n");
printf("        CAN FD Demo            \r\n");
printf(" ------------------------------ \r\n");

/* Set Message RAM Configuration */
CAN1_MessageRAMConfigSet(Can1MessageRAM);

CAN1_RxFifoCallbackRegister(CAN_RX_FIFO_0, APP_CAN_RxFifo0Callback, APP_STATE_CAN_RECEIVE);
CAN1_RxFifoCallbackRegister(CAN_RX_FIFO_1, APP_CAN_RxFifo1Callback, APP_STATE_CAN_RECEIVE);
CAN1_RxBuffersCallbackRegister(APP_CAN_RxBufferCallback, APP_STATE_CAN_RECEIVE);

display_menu();

while ( true )
{
    if (state == APP_STATE_CAN_USER_INPUT)
    {
        /* Read user input */
        scanf("%c", (char *) &amp;user_input);

        switch (user_input)
        {
            case '0':
                memset(txFiFo, 0x00, CAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                txBuffer = (CAN_TX_BUFFER *)txFiFo;
                txBuffer-&gt;id = WRITE_ID(0x45A);
                txBuffer-&gt;dlc = CANLengthToDlcGet(64);
                txBuffer-&gt;fdf = 1;
                txBuffer-&gt;brs = 1;
                for (loop_count = 0; loop_count &lt; 64; loop_count++){
                    txBuffer-&gt;data[loop_count] = loop_count;
                }                
                printf("  0: Send FD standard message with ID: 0x45A and 64 byte data 0 to 63.\r\n");
                CAN1_TxFifoCallbackRegister( APP_CAN_TxFifoCallback, (uintptr_t)APP_STATE_CAN_TRANSMIT );
                state = APP_STATE_CAN_IDLE;
                if (CAN1_MessageTransmitFifo(1, txBuffer) == false)
                {
                    printf(" Failed \r\n");
                }             
                break;
            case '1':
                memset(txFiFo, 0x00, CAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                txBuffer = (CAN_TX_BUFFER *)txFiFo;
                txBuffer-&gt;id = WRITE_ID(0x469);
                txBuffer-&gt;dlc = CANLengthToDlcGet(64);
                txBuffer-&gt;fdf = 1;
                txBuffer-&gt;brs = 1;
                for (loop_count = 128; loop_count &lt; 192; loop_count++){
                    txBuffer-&gt;data[loop_count - 128] = loop_count;
                }                
                printf("  1: Send FD standard message with ID: 0x469 and 64 byte data 128 to 191.\r\n");
                CAN1_TxFifoCallbackRegister( APP_CAN_TxFifoCallback, (uintptr_t)APP_STATE_CAN_TRANSMIT );
                state = APP_STATE_CAN_IDLE;
                if (CAN1_MessageTransmitFifo(1, txBuffer) == false)
                {
                    printf(" Failed \r\n");
                }             
                break;
            case '2':
                memset(txFiFo, 0x00, CAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                txBuffer = (CAN_TX_BUFFER *)txFiFo;
                txBuffer-&gt;id = 0x100000A5;
                txBuffer-&gt;dlc = CANLengthToDlcGet(64);
                txBuffer-&gt;xtd = 1;
                txBuffer-&gt;fdf = 1;
                txBuffer-&gt;brs = 1;
                for (loop_count = 0; loop_count &lt; 64; loop_count++){
                    txBuffer-&gt;data[loop_count] = loop_count;
                }
                printf("  2: Send FD extended message with ID: 0x100000A5 and 64 byte data 0 to 63.\r\n");
                CAN1_TxFifoCallbackRegister( APP_CAN_TxFifoCallback, (uintptr_t)APP_STATE_CAN_TRANSMIT );
                state = APP_STATE_CAN_IDLE;
                if (CAN1_MessageTransmitFifo(1, txBuffer) == false)
                {
                    printf(" Failed \r\n");
                }
                break;
            case '3':
                memset(txFiFo, 0x00, CAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                txBuffer = (CAN_TX_BUFFER *)txFiFo;
                txBuffer-&gt;id = 0x10000096;
                txBuffer-&gt;dlc = CANLengthToDlcGet(64);
                txBuffer-&gt;xtd = 1;
                txBuffer-&gt;fdf = 1;
                txBuffer-&gt;brs = 1;
                for (loop_count = 128; loop_count &lt; 192; loop_count++){
                    txBuffer-&gt;data[loop_count - 128] = loop_count;
                }
                printf("  3: Send FD extended message with ID: 0x10000096 and 64 byte data 128 to 191.\r\n");
                CAN1_TxFifoCallbackRegister( APP_CAN_TxFifoCallback, (uintptr_t)APP_STATE_CAN_TRANSMIT );
                state = APP_STATE_CAN_IDLE;
                if (CAN1_MessageTransmitFifo(1, txBuffer) == false)
                {
                    printf(" Failed \r\n");
                }
                break;
            case '4':
                memset(txFiFo, 0x00, CAN1_TX_FIFO_BUFFER_ELEMENT_SIZE);
                txBuffer = (CAN_TX_BUFFER *)txFiFo;
                txBuffer-&gt;id = WRITE_ID(0x469);
                txBuffer-&gt;dlc = 8;
                for (loop_count = 0; loop_count &lt; 8; loop_count++){
                    txBuffer-&gt;data[loop_count] = loop_count;
                }                
                printf("  4: Send normal standard message with ID: 0x469 and 8 byte data 0 to 7.\r\n");
                CAN1_TxFifoCallbackRegister( APP_CAN_TxFifoCallback, (uintptr_t)APP_STATE_CAN_TRANSMIT );
                state = APP_STATE_CAN_IDLE;
                if (CAN1_MessageTransmitFifo(1, txBuffer) == false)
                {
                    printf(" Failed \r\n");
                }             
                break;
            case 'm':
            case 'M':
                display_menu();
                break;

            default:
                printf(" Invalid Input \r\n");
                break;
        }
    }

    /* Check the application's current state. */
    switch (state)
    {
        case APP_STATE_CAN_IDLE:
        {
            /* Application can do other task here */
            break;
        }
        case APP_STATE_CAN_XFER_SUCCESSFUL:
        {
            if ((APP_STATES)xferContext == APP_STATE_CAN_TRANSMIT)
            {
                printf(" Success\r\n");
            }                
            state = APP_STATE_CAN_USER_INPUT;
            break;
        }
        case APP_STATE_CAN_XFER_ERROR:
        {
            if ((APP_STATES)xferContext == APP_STATE_CAN_RECEIVE)
            {
                printf(" Error in received message\r\n");
            }
            else
            {
                printf(" Failed\r\n");
            }
            state = APP_STATE_CAN_USER_INPUT;
            break;
        }
        default:
        {
            break;
        }
    }
}

/* Execution should not come here during normal operation */

return ( EXIT_FAILURE );
</code></pre>
<p>}
```</p>
<table class="data-table">
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CANx_Initialize</td>
<td>Initializes given instance of the CAN peripheral</td>
</tr>
<tr>
<td>CANx_MessageTransmit</td>
<td>Transmits a message into CAN bus from the specific Tx buffer</td>
</tr>
<tr>
<td>CANx_MessageTransmitFifo</td>
<td>Transmit multiple messages into CAN bus from Tx FIFO</td>
</tr>
<tr>
<td>CANx_TxFifoFreeLevelGet</td>
<td>Returns Tx FIFO Free Level</td>
</tr>
<tr>
<td>CANx_TxBufferIsBusy</td>
<td>Check if Transmission request is pending for the specific Tx buffer</td>
</tr>
<tr>
<td>CANx_TxEventFifoRead</td>
<td>Read Tx Event FIFO for the transmitted messages</td>
</tr>
<tr>
<td>CANx_TxEventFifoFillLevelGet</td>
<td>Returns Tx Event FIFO Fill Level</td>
</tr>
<tr>
<td>CANx_MessageReceive</td>
<td>Read a message from the specific Rx Buffer</td>
</tr>
<tr>
<td>CANx_RxBufferNumberGet</td>
<td>Get Rx Buffer Number</td>
</tr>
<tr>
<td>CANx_MessageReceiveFifo</td>
<td>Read messages from Rx FIFO0/FIFO1</td>
</tr>
<tr>
<td>CANx_RxFifoFillLevelGet</td>
<td>Returns Rx FIFO0/FIFO1 Fill Level</td>
</tr>
<tr>
<td>CANx_ErrorGet</td>
<td>Returns the error during transfer</td>
</tr>
<tr>
<td>CANx_ErrorCountGet</td>
<td>Returns the transmit and receive error count during transfer</td>
</tr>
<tr>
<td>CANx_InterruptGet</td>
<td>Returns the Interrupt status</td>
</tr>
<tr>
<td>CANx_InterruptClear</td>
<td>Clears Interrupt status</td>
</tr>
<tr>
<td>CANx_MessageRAMConfigSet</td>
<td>Set the Message RAM Configuration</td>
</tr>
<tr>
<td>CANx_StandardFilterElementSet</td>
<td>Set a standard filter element configuration</td>
</tr>
<tr>
<td>CANx_StandardFilterElementGet</td>
<td>Get a standard filter element configuration</td>
</tr>
<tr>
<td>CANx_ExtendedFilterElementSet</td>
<td>Set a Extended filter element configuration</td>
</tr>
<tr>
<td>CANx_ExtendedFilterElementGet</td>
<td>Get a Extended filter element configuration</td>
</tr>
<tr>
<td>CANx_SleepModeEnter</td>
<td>Puts the CAN Peripheral in sleep mode (clock stop request)</td>
</tr>
<tr>
<td>CANx_SleepModeExit</td>
<td>Exits CAN peripheral from sleep mode (clock stop request)</td>
</tr>
<tr>
<td>CANx_TxBuffersCallbackRegister</td>
<td>Sets the pointer to the function (and it's contextHandle) to be called when the given CAN's Tx transfer events occur</td>
</tr>
<tr>
<td>CANx_TxFifoCallbackRegister</td>
<td>Sets the pointer to the function (and it's contextHandle) to be called when the given CAN's Tx transfer events occur</td>
</tr>
<tr>
<td>CANx_TxEventFifoCallbackRegister</td>
<td>Sets the pointer to the function (and it's contextHandle) to be called when the given CAN's Tx transfer events occur</td>
</tr>
<tr>
<td>CANx_BitTimingCalculationGet</td>
<td>Returns the bit timing information</td>
</tr>
<tr>
<td>CANx_BitTimingSet</td>
<td>Sets the bit timing</td>
</tr>
<tr>
<td>CANx_RxBuffersCallbackRegister</td>
<td>Sets the pointer to the function (and it's contextHandle) to be called when the given CAN's Rx transfer events occur</td>
</tr>
<tr>
<td>CANx_RxFifoCallbackRegister</td>
<td>Sets the pointer to the function (and it's contextHandle) to be called when the given CAN's Rx transfer events occur</td>
</tr>
</tbody>
</table>
<table class="data-table">
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CAN_RX_FIFO_NUM</td>
<td>Enum</td>
<td>CAN Rx FIFO Number</td>
</tr>
<tr>
<td>CAN_INTERRUPT_MASK</td>
<td>Enum</td>
<td>CAN Interrupt Mask</td>
</tr>
<tr>
<td>CAN_ERROR</td>
<td>Typedef</td>
<td>CAN Transfer Error data type</td>
</tr>
<tr>
<td>CAN_TX_FIFO_CALLBACK</td>
<td>Typedef</td>
<td>CAN Callback Function Pointer for Tx FIFO</td>
</tr>
<tr>
<td>CAN_TXRX_BUFFERS_CALLBACK</td>
<td>Typedef</td>
<td>CAN Callback Function Pointer for TX/RX Buffers</td>
</tr>
<tr>
<td>CAN_TX_EVENT_FIFO_CALLBACK</td>
<td>Typedef</td>
<td>CAN Callback Function Pointer for Tx Event FIFO</td>
</tr>
<tr>
<td>CAN_RX_FIFO_CALLBACK</td>
<td>Typedef</td>
<td>CAN Callback Function Pointer for Rx FIFO0/FIFO1</td>
</tr>
<tr>
<td>CAN_MSG_RAM_CONFIG</td>
<td>Struct</td>
<td>CAN Message RAM Configuration structure</td>
</tr>
<tr>
<td>CAN_RX_BUFFER</td>
<td>Struct</td>
<td>CAN Rx Buffer and FIFO Element Structure</td>
</tr>
<tr>
<td>CAN_TX_BUFFER</td>
<td>Struct</td>
<td>CAN Tx Buffer Element Structure</td>
</tr>
<tr>
<td>CAN_TX_EVENT_FIFO</td>
<td>Struct</td>
<td>CAN Tx Event FIFO Element Structure</td>
</tr>
<tr>
<td>CAN_TX_FIFO_CALLBACK_OBJ</td>
<td>Struct</td>
<td>CAN transfer event callback structure for Tx FIFO</td>
</tr>
<tr>
<td>CAN_TXRX_BUFFERS_CALLBACK_OBJ</td>
<td>Struct</td>
<td>CAN transfer event callback structure for Tx/Rx Buffers</td>
</tr>
<tr>
<td>CAN_TX_EVENT_FIFO_CALLBACK_OBJ</td>
<td>Struct</td>
<td>CAN transfer event callback structure for Tx Event FIFO</td>
</tr>
<tr>
<td>CAN_RX_FIFO_CALLBACK_OBJ</td>
<td>Struct</td>
<td>CAN transfer event callback structure for Rx FIFO0/FIFO1</td>
</tr>
<tr>
<td>CAN_NOMINAL_BIT_TIMING</td>
<td>Struct</td>
<td>Nominal bit timing parameters</td>
</tr>
<tr>
<td>CAN_BIT_TIMING</td>
<td>Struct</td>
<td>Bit timing parameters</td>
</tr>
</tbody>
</table>
            </main>
        </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
</body>

</html>